webpackHotUpdate(0,{

/***/ "./src/app/main.js":
/*!*************************!*\
  !*** ./src/app/main.js ***!
  \*************************/
/*! exports provided: main */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_utils_Selector_js__ = __webpack_require__(/*! utils/Selector.js */ \"./src/app/utils/Selector.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_utils_inboxsdk_js__ = __webpack_require__(/*! utils/inboxsdk.js */ \"./src/app/utils/inboxsdk.js\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_utils_inboxsdk_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_utils_inboxsdk_js__);\n\n\nclass Main {\n  constructor() {\n    Object(__WEBPACK_IMPORTED_MODULE_0_utils_Selector_js__[\"a\" /* selector */])(document).ready(this.bind());\n  }\n\n  bind() {\n    console.log(\"Document Ready!!!!! - Loaded Content Scripts\");\n    alert(\"CCC\");\n  }\n}\n\nconst main = new Main();\n/* harmony export (immutable) */ __webpack_exports__[\"main\"] = main;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2FwcC9tYWluLmpzPzRmYzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VsZWN0b3IgfSBmcm9tICd1dGlscy9TZWxlY3Rvci5qcydcbmltcG9ydCB7IEluYm94U0RLIH0gZnJvbSAndXRpbHMvaW5ib3hzZGsuanMnXG5jbGFzcyBNYWluIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHNlbGVjdG9yKGRvY3VtZW50KS5yZWFkeSh0aGlzLmJpbmQoKSlcbiAgfVxuXG4gICAgYmluZCgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRG9jdW1lbnQgUmVhZHkhISEhISAtIExvYWRlZCBDb250ZW50IFNjcmlwdHNcIilcbiAgICAgIGFsZXJ0KFwiQ0NDXCIpXG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgbWFpbiA9IG5ldyBNYWluKClcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwL21haW4uanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTs7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/main.js\n");

/***/ }),

/***/ "./src/app/utils/inboxsdk.js":
/*!***********************************!*\
  !*** ./src/app/utils/inboxsdk.js ***!
  \***********************************/
/*! dynamic exports provided */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n * InboxSDK\n * https://www.inboxsdk.com/\n *\n * The use of InboxSDK is governed by the Terms of Services located at\n * https://www.inboxsdk.com/terms\n\n\n *  __    __            _     _          _                _                      ___                 _ _ ___\n * / / /\\ \\ \\__ _ _ __ | |_  | |_ ___   | |__   __ _  ___| | __   ___  _ __     / _ \\_ __ ___   __ _(_) / _ \\\n * \\ \\/  \\/ / _` | '_ \\| __| | __/ _ \\  | '_ \\ / _` |/ __| |/ /  / _ \\| '_ \\   / /_\\/ '_ ` _ \\ / _` | | \\// /\n *  \\  /\\  / (_| | | | | |_  | || (_) | | | | | (_| | (__|   <  | (_) | | | | / /_\\\\| | | | | | (_| | | | \\/\n *   \\/  \\/ \\__,_|_| |_|\\__|  \\__\\___/  |_| |_|\\__,_|\\___|_|\\_\\  \\___/|_| |_| \\____/|_| |_| |_|\\__,_|_|_| ()\n *\n * Like complex reverse engineering? Want to make Gmail and Inbox a hackable platform?\n *\n * Join us at: www.streak.com/careers?source=sdk\n */\n\n(function e(t, n, r) {\n  function s(o, u) {\n    if (!n[o]) {\n      if (!t[o]) {\n        var a = typeof require == \"function\" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw f.code = \"MODULE_NOT_FOUND\", f;\n      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\n        var n = t[o][1][e];return s(n ? n : e);\n      }, l, l.exports, e, t, n, r);\n    }return n[o].exports;\n  }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;\n})({ 1: [function (require, module, exports) {\n    module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };\n  }, { \"core-js/library/fn/json/stringify\": 5 }], 2: [function (require, module, exports) {\n    module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n  }, { \"core-js/library/fn/object/assign\": 6 }], 3: [function (require, module, exports) {\n    module.exports = { \"default\": require(\"core-js/library/fn/object/keys\"), __esModule: true };\n  }, { \"core-js/library/fn/object/keys\": 7 }], 4: [function (require, module, exports) {\n    (function (global) {\n      // We only target browsers that natively support Promises, so we replace\n      // Babel's Promise helper with a reference to the native promise.\n      module.exports = {\n        __esModule: true,\n        default: global.Promise\n      };\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}], 5: [function (require, module, exports) {\n    var core = require('../../modules/_core'),\n        $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\n    module.exports = function stringify(it) {\n      // eslint-disable-line no-unused-vars\n      return $JSON.stringify.apply($JSON, arguments);\n    };\n  }, { \"../../modules/_core\": 12 }], 6: [function (require, module, exports) {\n    require('../../modules/es6.object.assign');\n    module.exports = require('../../modules/_core').Object.assign;\n  }, { \"../../modules/_core\": 12, \"../../modules/es6.object.assign\": 43 }], 7: [function (require, module, exports) {\n    require('../../modules/es6.object.keys');\n    module.exports = require('../../modules/_core').Object.keys;\n  }, { \"../../modules/_core\": 12, \"../../modules/es6.object.keys\": 44 }], 8: [function (require, module, exports) {\n    module.exports = function (it) {\n      if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n      return it;\n    };\n  }, {}], 9: [function (require, module, exports) {\n    var isObject = require('./_is-object');\n    module.exports = function (it) {\n      if (!isObject(it)) throw TypeError(it + ' is not an object!');\n      return it;\n    };\n  }, { \"./_is-object\": 25 }], 10: [function (require, module, exports) {\n    // false -> Array#indexOf\n    // true  -> Array#includes\n    var toIObject = require('./_to-iobject'),\n        toLength = require('./_to-length'),\n        toIndex = require('./_to-index');\n    module.exports = function (IS_INCLUDES) {\n      return function ($this, el, fromIndex) {\n        var O = toIObject($this),\n            length = toLength(O.length),\n            index = toIndex(fromIndex, length),\n            value;\n        // Array#includes uses SameValueZero equality algorithm\n        if (IS_INCLUDES && el != el) while (length > index) {\n          value = O[index++];\n          if (value != value) return true;\n          // Array#toIndex ignores holes, Array#includes - not\n        } else for (; length > index; index++) if (IS_INCLUDES || index in O) {\n          if (O[index] === el) return IS_INCLUDES || index || 0;\n        }return !IS_INCLUDES && -1;\n      };\n    };\n  }, { \"./_to-index\": 36, \"./_to-iobject\": 38, \"./_to-length\": 39 }], 11: [function (require, module, exports) {\n    var toString = {}.toString;\n\n    module.exports = function (it) {\n      return toString.call(it).slice(8, -1);\n    };\n  }, {}], 12: [function (require, module, exports) {\n    var core = module.exports = { version: '2.4.0' };\n    if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n  }, {}], 13: [function (require, module, exports) {\n    // optional / simple context binding\n    var aFunction = require('./_a-function');\n    module.exports = function (fn, that, length) {\n      aFunction(fn);\n      if (that === undefined) return fn;\n      switch (length) {\n        case 1:\n          return function (a) {\n            return fn.call(that, a);\n          };\n        case 2:\n          return function (a, b) {\n            return fn.call(that, a, b);\n          };\n        case 3:\n          return function (a, b, c) {\n            return fn.call(that, a, b, c);\n          };\n      }\n      return function () /* ...args */{\n        return fn.apply(that, arguments);\n      };\n    };\n  }, { \"./_a-function\": 8 }], 14: [function (require, module, exports) {\n    // 7.2.1 RequireObjectCoercible(argument)\n    module.exports = function (it) {\n      if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n      return it;\n    };\n  }, {}], 15: [function (require, module, exports) {\n    // Thank's IE8 for his funny defineProperty\n    module.exports = !require('./_fails')(function () {\n      return Object.defineProperty({}, 'a', { get: function () {\n          return 7;\n        } }).a != 7;\n    });\n  }, { \"./_fails\": 19 }], 16: [function (require, module, exports) {\n    var isObject = require('./_is-object'),\n        document = require('./_global').document\n    // in old IE typeof document.createElement is 'object'\n    ,\n        is = isObject(document) && isObject(document.createElement);\n    module.exports = function (it) {\n      return is ? document.createElement(it) : {};\n    };\n  }, { \"./_global\": 20, \"./_is-object\": 25 }], 17: [function (require, module, exports) {\n    // IE 8- don't enum bug keys\n    module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');\n  }, {}], 18: [function (require, module, exports) {\n    var global = require('./_global'),\n        core = require('./_core'),\n        ctx = require('./_ctx'),\n        hide = require('./_hide'),\n        PROTOTYPE = 'prototype';\n\n    var $export = function (type, name, source) {\n      var IS_FORCED = type & $export.F,\n          IS_GLOBAL = type & $export.G,\n          IS_STATIC = type & $export.S,\n          IS_PROTO = type & $export.P,\n          IS_BIND = type & $export.B,\n          IS_WRAP = type & $export.W,\n          exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),\n          expProto = exports[PROTOTYPE],\n          target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],\n          key,\n          own,\n          out;\n      if (IS_GLOBAL) source = name;\n      for (key in source) {\n        // contains in native\n        own = !IS_FORCED && target && target[key] !== undefined;\n        if (own && key in exports) continue;\n        // export native or passed\n        out = own ? target[key] : source[key];\n        // prevent global pollution for namespaces\n        exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n        // bind timers to global for call from export context\n        : IS_BIND && own ? ctx(out, global)\n        // wrap global constructors for prevent change them in library\n        : IS_WRAP && target[key] == out ? function (C) {\n          var F = function (a, b, c) {\n            if (this instanceof C) {\n              switch (arguments.length) {\n                case 0:\n                  return new C();\n                case 1:\n                  return new C(a);\n                case 2:\n                  return new C(a, b);\n              }return new C(a, b, c);\n            }return C.apply(this, arguments);\n          };\n          F[PROTOTYPE] = C[PROTOTYPE];\n          return F;\n          // make static versions for prototype methods\n        }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n        // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n        if (IS_PROTO) {\n          (exports.virtual || (exports.virtual = {}))[key] = out;\n          // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n          if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n        }\n      }\n    };\n    // type bitmap\n    $export.F = 1; // forced\n    $export.G = 2; // global\n    $export.S = 4; // static\n    $export.P = 8; // proto\n    $export.B = 16; // bind\n    $export.W = 32; // wrap\n    $export.U = 64; // safe\n    $export.R = 128; // real proto method for `library` \n    module.exports = $export;\n  }, { \"./_core\": 12, \"./_ctx\": 13, \"./_global\": 20, \"./_hide\": 22 }], 19: [function (require, module, exports) {\n    module.exports = function (exec) {\n      try {\n        return !!exec();\n      } catch (e) {\n        return true;\n      }\n    };\n  }, {}], 20: [function (require, module, exports) {\n    // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n    var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n    if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n  }, {}], 21: [function (require, module, exports) {\n    var hasOwnProperty = {}.hasOwnProperty;\n    module.exports = function (it, key) {\n      return hasOwnProperty.call(it, key);\n    };\n  }, {}], 22: [function (require, module, exports) {\n    var dP = require('./_object-dp'),\n        createDesc = require('./_property-desc');\n    module.exports = require('./_descriptors') ? function (object, key, value) {\n      return dP.f(object, key, createDesc(1, value));\n    } : function (object, key, value) {\n      object[key] = value;\n      return object;\n    };\n  }, { \"./_descriptors\": 15, \"./_object-dp\": 27, \"./_property-desc\": 33 }], 23: [function (require, module, exports) {\n    module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n      return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () {\n          return 7;\n        } }).a != 7;\n    });\n  }, { \"./_descriptors\": 15, \"./_dom-create\": 16, \"./_fails\": 19 }], 24: [function (require, module, exports) {\n    // fallback for non-array-like ES3 and non-enumerable old V8 strings\n    var cof = require('./_cof');\n    module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n      return cof(it) == 'String' ? it.split('') : Object(it);\n    };\n  }, { \"./_cof\": 11 }], 25: [function (require, module, exports) {\n    module.exports = function (it) {\n      return typeof it === 'object' ? it !== null : typeof it === 'function';\n    };\n  }, {}], 26: [function (require, module, exports) {\n    'use strict';\n    // 19.1.2.1 Object.assign(target, source, ...)\n\n    var getKeys = require('./_object-keys'),\n        gOPS = require('./_object-gops'),\n        pIE = require('./_object-pie'),\n        toObject = require('./_to-object'),\n        IObject = require('./_iobject'),\n        $assign = Object.assign;\n\n    // should work with symbols and should have deterministic property order (V8 bug)\n    module.exports = !$assign || require('./_fails')(function () {\n      var A = {},\n          B = {},\n          S = Symbol(),\n          K = 'abcdefghijklmnopqrst';\n      A[S] = 7;\n      K.split('').forEach(function (k) {\n        B[k] = k;\n      });\n      return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n    }) ? function assign(target, source) {\n      // eslint-disable-line no-unused-vars\n      var T = toObject(target),\n          aLen = arguments.length,\n          index = 1,\n          getSymbols = gOPS.f,\n          isEnum = pIE.f;\n      while (aLen > index) {\n        var S = IObject(arguments[index++]),\n            keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),\n            length = keys.length,\n            j = 0,\n            key;\n        while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n      }return T;\n    } : $assign;\n  }, { \"./_fails\": 19, \"./_iobject\": 24, \"./_object-gops\": 28, \"./_object-keys\": 30, \"./_object-pie\": 31, \"./_to-object\": 40 }], 27: [function (require, module, exports) {\n    var anObject = require('./_an-object'),\n        IE8_DOM_DEFINE = require('./_ie8-dom-define'),\n        toPrimitive = require('./_to-primitive'),\n        dP = Object.defineProperty;\n\n    exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n      anObject(O);\n      P = toPrimitive(P, true);\n      anObject(Attributes);\n      if (IE8_DOM_DEFINE) try {\n        return dP(O, P, Attributes);\n      } catch (e) {/* empty */}\n      if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n      if ('value' in Attributes) O[P] = Attributes.value;\n      return O;\n    };\n  }, { \"./_an-object\": 9, \"./_descriptors\": 15, \"./_ie8-dom-define\": 23, \"./_to-primitive\": 41 }], 28: [function (require, module, exports) {\n    exports.f = Object.getOwnPropertySymbols;\n  }, {}], 29: [function (require, module, exports) {\n    var has = require('./_has'),\n        toIObject = require('./_to-iobject'),\n        arrayIndexOf = require('./_array-includes')(false),\n        IE_PROTO = require('./_shared-key')('IE_PROTO');\n\n    module.exports = function (object, names) {\n      var O = toIObject(object),\n          i = 0,\n          result = [],\n          key;\n      for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n      // Don't enum bug & hidden keys\n      while (names.length > i) if (has(O, key = names[i++])) {\n        ~arrayIndexOf(result, key) || result.push(key);\n      }\n      return result;\n    };\n  }, { \"./_array-includes\": 10, \"./_has\": 21, \"./_shared-key\": 34, \"./_to-iobject\": 38 }], 30: [function (require, module, exports) {\n    // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n    var $keys = require('./_object-keys-internal'),\n        enumBugKeys = require('./_enum-bug-keys');\n\n    module.exports = Object.keys || function keys(O) {\n      return $keys(O, enumBugKeys);\n    };\n  }, { \"./_enum-bug-keys\": 17, \"./_object-keys-internal\": 29 }], 31: [function (require, module, exports) {\n    exports.f = {}.propertyIsEnumerable;\n  }, {}], 32: [function (require, module, exports) {\n    // most Object methods by ES6 should accept primitives\n    var $export = require('./_export'),\n        core = require('./_core'),\n        fails = require('./_fails');\n    module.exports = function (KEY, exec) {\n      var fn = (core.Object || {})[KEY] || Object[KEY],\n          exp = {};\n      exp[KEY] = exec(fn);\n      $export($export.S + $export.F * fails(function () {\n        fn(1);\n      }), 'Object', exp);\n    };\n  }, { \"./_core\": 12, \"./_export\": 18, \"./_fails\": 19 }], 33: [function (require, module, exports) {\n    module.exports = function (bitmap, value) {\n      return {\n        enumerable: !(bitmap & 1),\n        configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        value: value\n      };\n    };\n  }, {}], 34: [function (require, module, exports) {\n    var shared = require('./_shared')('keys'),\n        uid = require('./_uid');\n    module.exports = function (key) {\n      return shared[key] || (shared[key] = uid(key));\n    };\n  }, { \"./_shared\": 35, \"./_uid\": 42 }], 35: [function (require, module, exports) {\n    var global = require('./_global'),\n        SHARED = '__core-js_shared__',\n        store = global[SHARED] || (global[SHARED] = {});\n    module.exports = function (key) {\n      return store[key] || (store[key] = {});\n    };\n  }, { \"./_global\": 20 }], 36: [function (require, module, exports) {\n    var toInteger = require('./_to-integer'),\n        max = Math.max,\n        min = Math.min;\n    module.exports = function (index, length) {\n      index = toInteger(index);\n      return index < 0 ? max(index + length, 0) : min(index, length);\n    };\n  }, { \"./_to-integer\": 37 }], 37: [function (require, module, exports) {\n    // 7.1.4 ToInteger\n    var ceil = Math.ceil,\n        floor = Math.floor;\n    module.exports = function (it) {\n      return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n    };\n  }, {}], 38: [function (require, module, exports) {\n    // to indexed object, toObject with fallback for non-array-like ES3 strings\n    var IObject = require('./_iobject'),\n        defined = require('./_defined');\n    module.exports = function (it) {\n      return IObject(defined(it));\n    };\n  }, { \"./_defined\": 14, \"./_iobject\": 24 }], 39: [function (require, module, exports) {\n    // 7.1.15 ToLength\n    var toInteger = require('./_to-integer'),\n        min = Math.min;\n    module.exports = function (it) {\n      return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n    };\n  }, { \"./_to-integer\": 37 }], 40: [function (require, module, exports) {\n    // 7.1.13 ToObject(argument)\n    var defined = require('./_defined');\n    module.exports = function (it) {\n      return Object(defined(it));\n    };\n  }, { \"./_defined\": 14 }], 41: [function (require, module, exports) {\n    // 7.1.1 ToPrimitive(input [, PreferredType])\n    var isObject = require('./_is-object');\n    // instead of the ES6 spec version, we didn't implement @@toPrimitive case\n    // and the second argument - flag - preferred type is a string\n    module.exports = function (it, S) {\n      if (!isObject(it)) return it;\n      var fn, val;\n      if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n      if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n      if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n      throw TypeError(\"Can't convert object to primitive value\");\n    };\n  }, { \"./_is-object\": 25 }], 42: [function (require, module, exports) {\n    var id = 0,\n        px = Math.random();\n    module.exports = function (key) {\n      return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n    };\n  }, {}], 43: [function (require, module, exports) {\n    // 19.1.3.1 Object.assign(target, source)\n    var $export = require('./_export');\n\n    $export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n  }, { \"./_export\": 18, \"./_object-assign\": 26 }], 44: [function (require, module, exports) {\n    // 19.1.2.14 Object.keys(O)\n    var toObject = require('./_to-object'),\n        $keys = require('./_object-keys');\n\n    require('./_object-sap')('keys', function () {\n      return function keys(it) {\n        return $keys(toObject(it));\n      };\n    });\n  }, { \"./_object-keys\": 30, \"./_object-sap\": 32, \"./_to-object\": 40 }], 45: [function (require, module, exports) {\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    module.exports = fromPairs;\n  }, {}], 46: [function (require, module, exports) {\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    module.exports = isObject;\n  }, {}], 47: [function (require, module, exports) {\n    'use strict';\n\n    module.exports = once;\n\n    function once(func) {\n      if (typeof func != 'function') {\n        throw new Error('Parameter must be function');\n      }\n      var result;\n      return function () {\n        if (func) {\n          var tempFunc = func;\n          func = undefined;\n          result = tempFunc.apply(this, arguments);\n        }\n        return result;\n      };\n    }\n  }, {}], 48: [function (require, module, exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var _promise = require(\"babel-runtime/core-js/promise\");\n\n    var _promise2 = _interopRequireDefault(_promise);\n\n    exports.default = delay;\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n\n    function delay(time, value) {\n      return new _promise2.default(function (resolve) {\n        setTimeout(function () {\n          resolve(value);\n        }, time);\n      });\n    }\n    module.exports = exports[\"default\"];\n  }, { \"babel-runtime/core-js/promise\": 4 }], 49: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    'use strict';\n\n    // If obj.hasOwnProperty has been overridden, then calling\n    // obj.hasOwnProperty(prop) will break.\n    // See: https://github.com/joyent/node/issues/1707\n\n    function hasOwnProperty(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n\n    module.exports = function (qs, sep, eq, options) {\n      sep = sep || '&';\n      eq = eq || '=';\n      var obj = {};\n\n      if (typeof qs !== 'string' || qs.length === 0) {\n        return obj;\n      }\n\n      var regexp = /\\+/g;\n      qs = qs.split(sep);\n\n      var maxKeys = 1000;\n      if (options && typeof options.maxKeys === 'number') {\n        maxKeys = options.maxKeys;\n      }\n\n      var len = qs.length;\n      // maxKeys <= 0 means that we should not limit keys count\n      if (maxKeys > 0 && len > maxKeys) {\n        len = maxKeys;\n      }\n\n      for (var i = 0; i < len; ++i) {\n        var x = qs[i].replace(regexp, '%20'),\n            idx = x.indexOf(eq),\n            kstr,\n            vstr,\n            k,\n            v;\n\n        if (idx >= 0) {\n          kstr = x.substr(0, idx);\n          vstr = x.substr(idx + 1);\n        } else {\n          kstr = x;\n          vstr = '';\n        }\n\n        k = decodeURIComponent(kstr);\n        v = decodeURIComponent(vstr);\n\n        if (!hasOwnProperty(obj, k)) {\n          obj[k] = v;\n        } else if (isArray(obj[k])) {\n          obj[k].push(v);\n        } else {\n          obj[k] = [obj[k], v];\n        }\n      }\n\n      return obj;\n    };\n\n    var isArray = Array.isArray || function (xs) {\n      return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n  }, {}], 50: [function (require, module, exports) {\n    // Copyright Joyent, Inc. and other Node contributors.\n    //\n    // Permission is hereby granted, free of charge, to any person obtaining a\n    // copy of this software and associated documentation files (the\n    // \"Software\"), to deal in the Software without restriction, including\n    // without limitation the rights to use, copy, modify, merge, publish,\n    // distribute, sublicense, and/or sell copies of the Software, and to permit\n    // persons to whom the Software is furnished to do so, subject to the\n    // following conditions:\n    //\n    // The above copyright notice and this permission notice shall be included\n    // in all copies or substantial portions of the Software.\n    //\n    // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n    // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n    'use strict';\n\n    var stringifyPrimitive = function (v) {\n      switch (typeof v) {\n        case 'string':\n          return v;\n\n        case 'boolean':\n          return v ? 'true' : 'false';\n\n        case 'number':\n          return isFinite(v) ? v : '';\n\n        default:\n          return '';\n      }\n    };\n\n    module.exports = function (obj, sep, eq, name) {\n      sep = sep || '&';\n      eq = eq || '=';\n      if (obj === null) {\n        obj = undefined;\n      }\n\n      if (typeof obj === 'object') {\n        return map(objectKeys(obj), function (k) {\n          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n          if (isArray(obj[k])) {\n            return map(obj[k], function (v) {\n              return ks + encodeURIComponent(stringifyPrimitive(v));\n            }).join(sep);\n          } else {\n            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n          }\n        }).join(sep);\n      }\n\n      if (!name) return '';\n      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n    };\n\n    var isArray = Array.isArray || function (xs) {\n      return Object.prototype.toString.call(xs) === '[object Array]';\n    };\n\n    function map(xs, f) {\n      if (xs.map) return xs.map(f);\n      var res = [];\n      for (var i = 0; i < xs.length; i++) {\n        res.push(f(xs[i], i));\n      }\n      return res;\n    }\n\n    var objectKeys = Object.keys || function (obj) {\n      var res = [];\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n      }\n      return res;\n    };\n  }, {}], 51: [function (require, module, exports) {\n    'use strict';\n\n    exports.decode = exports.parse = require('./decode');\n    exports.encode = exports.stringify = require('./encode');\n  }, { \"./decode\": 49, \"./encode\": 50 }], 52: [function (require, module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var _keys = require('babel-runtime/core-js/object/keys');\n\n    var _keys2 = _interopRequireDefault(_keys);\n\n    var _assign = require('babel-runtime/core-js/object/assign');\n\n    var _assign2 = _interopRequireDefault(_assign);\n\n    var _promise = require('babel-runtime/core-js/promise');\n\n    var _promise2 = _interopRequireDefault(_promise);\n\n    exports.default = ajax;\n\n    var _querystring = require('querystring');\n\n    var _querystring2 = _interopRequireDefault(_querystring);\n\n    var _pdelay = require('pdelay');\n\n    var _pdelay2 = _interopRequireDefault(_pdelay);\n\n    var _cachebustUrl = require('./cachebust-url');\n\n    var _cachebustUrl2 = _interopRequireDefault(_cachebustUrl);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n\n    var MAX_TIMEOUT = 64 * 1000; //64 seconds\n\n\n    var MAX_RETRIES = 5;\n    var serversToIgnore = {};\n\n    // Simple ajax helper.\n    // opts:\n    // * url\n    // * [method]\n    // * [cachebust] - boolean\n    // * [headers] - object\n    // * [xhrFields] - object\n    // * [data]\n    function ajax(opts) {\n      if (!opts || typeof opts.url !== 'string') {\n        throw new Error('URL must be given');\n      }\n      return new _promise2.default(function (resolve, reject) {\n        var method = opts.method ? opts.method : \"GET\";\n        var url = opts.url;\n        var stringData = undefined;\n        if (opts.data) {\n          stringData = typeof opts.data === \"string\" ? opts.data : _querystring2.default.stringify(opts.data);\n          if (method === \"GET\" || method === \"HEAD\") {\n            url += (/\\?/.test(url) ? \"&\" : \"?\") + stringData;\n            stringData = null;\n          }\n        }\n\n        var match = url.match(/(?:(?:[a-z]+:)?\\/\\/)?([^/]*)\\//);\n        if (!match) {\n          throw new Error(\"Failed to match url\");\n        }\n        var server = match[1];\n        if (Object.prototype.hasOwnProperty.call(serversToIgnore, server)) {\n          reject(new Error('Server at ' + url + ' has told us to stop connecting'));\n          return;\n        }\n\n        if (opts.cachebust) {\n          url = (0, _cachebustUrl2.default)(url);\n        }\n\n        var xhr = new XMLHttpRequest();\n        (0, _assign2.default)(xhr, opts.xhrFields);\n        xhr.onerror = function (event) {\n          if ((opts.retryNum || 0) < MAX_RETRIES) {\n            if (xhr.status === 502 || (xhr.status === 0 || xhr.status >= 500) && (method === \"GET\" || method === \"HEAD\" || opts.canRetry === true)) {\n              resolve(_retry(opts));\n              return;\n            }\n          }\n\n          var err = (0, _assign2.default)(new Error('Failed to load ' + url), {\n            event: event, xhr: xhr, status: xhr.status\n          });\n\n          // give a way for a server to tell us to go away for now. Good fallback\n          // in case a bug ever causes clients to spam a server with requests.\n          if (xhr.status == 490) {\n            serversToIgnore[server] = true;\n          }\n          reject(err);\n        };\n        xhr.onload = function (event) {\n          if (xhr.status === 200) {\n            resolve({\n              xhr: xhr,\n              text: xhr.responseText\n            });\n          } else {\n            xhr.onerror(event);\n          }\n        };\n        xhr.open(method, url, true);\n        if (opts.headers) {\n          (function () {\n            var headers = opts.headers;\n\n            (0, _keys2.default)(headers).forEach(function (name) {\n              var value = headers[name];\n              xhr.setRequestHeader(name, value);\n            });\n          })();\n        }\n        xhr.send(stringData);\n      });\n    }\n\n    function _retry(opts) {\n      var retryNum = (opts.retryNum || 0) + 1;\n\n      // 2000 4000 8000...\n      var retryTimeout = Math.min(Math.pow(2, retryNum) * 1000, MAX_TIMEOUT);\n\n      return (0, _pdelay2.default)(retryTimeout).then(function () {\n        return ajax((0, _assign2.default)({}, opts, { retryNum: retryNum }));\n      });\n    }\n    module.exports = exports['default'];\n  }, { \"./cachebust-url\": 53, \"babel-runtime/core-js/object/assign\": 2, \"babel-runtime/core-js/object/keys\": 3, \"babel-runtime/core-js/promise\": 4, \"pdelay\": 48, \"querystring\": 51 }], 53: [function (require, module, exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.default = cachebustUrl;\n    var r = /([?&])_=[^&]*/;\n    var nonce = Date.now() + Math.floor(Math.random() * Math.pow(2, 32));\n\n    function cachebustUrl(url) {\n      if (r.test(url)) {\n        return url.replace(r, \"$1_=\" + nonce++);\n      } else {\n        return url + (/\\?/.test(url) ? \"&\" : \"?\") + \"_=\" + nonce++;\n      }\n    }\n    module.exports = exports[\"default\"];\n  }, {}], 54: [function (require, module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var _promise = require('babel-runtime/core-js/promise');\n\n    var _promise2 = _interopRequireDefault(_promise);\n\n    exports.default = connectivityTest;\n\n    var _cachebustUrl = require('./cachebust-url');\n\n    var _cachebustUrl2 = _interopRequireDefault(_cachebustUrl);\n\n    var _fromPairs = require('lodash/fromPairs');\n\n    var _fromPairs2 = _interopRequireDefault(_fromPairs);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n\n    var URLS = ['https://mailfoogae.appspot.com/build/images/composeOverflowToggle.png', 'https://www.streak.com/build/images/composeOverflowToggle.png', 'https://www.inboxsdk.com/images/logo-red.png'];\n\n    function imageTest(url) {\n      return new _promise2.default(function (resolve, reject) {\n        var img = document.createElement('img');\n        img.onload = function () {\n          resolve(true);\n        };\n        img.onloadend = img.onerror = function () {\n          resolve(false);\n        };\n        img.src = (0, _cachebustUrl2.default)(url);\n      });\n    }\n\n    function connectivityTest() {\n      return _promise2.default.all(URLS.map(function (url) {\n        return imageTest(url).then(function (success) {\n          return [url, success];\n        });\n      })).then(function (results) {\n        return (0, _fromPairs2.default)(results);\n      });\n    }\n    module.exports = exports['default'];\n  }, { \"./cachebust-url\": 53, \"babel-runtime/core-js/promise\": 4, \"lodash/fromPairs\": 45 }], 55: [function (require, module, exports) {\n    (function (global) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = getExtensionId;\n      function getExtensionId() {\n        if (global.chrome && global.chrome.extension && global.chrome.extension.getURL) {\n          return global.chrome.extension.getURL('');\n        }\n        return null;\n      }\n      module.exports = exports['default'];\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}], 56: [function (require, module, exports) {\n    (function (global) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = getSessionId;\n      function getSessionId() {\n        var attrValue = global.document && document.documentElement.getAttribute('data-inboxsdk-session-id');\n        if (typeof attrValue === 'string') {\n          return attrValue;\n        } else {\n          var sessionId = Date.now() + '-' + Math.random();\n          if (global.document) {\n            document.documentElement.setAttribute('data-inboxsdk-session-id', sessionId);\n          }\n          return sessionId;\n        }\n      }\n      module.exports = exports['default'];\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}], 57: [function (require, module, exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.default = getStackTrace;\n    function getStackTrace() {\n      var err = new Error(\"Stack saver\");\n      // Cut the first two lines off. The first line has the error name, and the\n      // second line is inside this function.\n      return (\"\" + err.stack).replace(/^([^\\n]*\\n){2}/, '');\n    }\n    module.exports = exports[\"default\"];\n  }, {}], 58: [function (require, module, exports) {\n    (function (global) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _promise = require('babel-runtime/core-js/promise');\n\n      var _promise2 = _interopRequireDefault(_promise);\n\n      exports.default = loadScript;\n\n      var _connectivityTest = require('./connectivity-test');\n\n      var _connectivityTest2 = _interopRequireDefault(_connectivityTest);\n\n      var _logError = require('./log-error');\n\n      var _logError2 = _interopRequireDefault(_logError);\n\n      var _ajax = require('./ajax');\n\n      var _ajax2 = _interopRequireDefault(_ajax);\n\n      var _pdelay = require('pdelay');\n\n      var _pdelay2 = _interopRequireDefault(_pdelay);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : { default: obj };\n      }\n\n      var once = require('lodash/once');\n\n      var isContentScript = once(function () {\n        if (global.chrome && global.chrome.extension) return true;\n        if (global.safari && global.safari.extension) return true;\n        return false;\n      });\n\n      function addScriptToPage(url, cors) {\n        var script = document.createElement('script');\n        script.type = 'text/javascript';\n        if (cors) {\n          script.crossOrigin = 'anonymous';\n        }\n\n        var promise = new _promise2.default(function (resolve, reject) {\n          script.addEventListener('error', function (event) {\n            reject(event.error || new Error(event.message || \"Load failure: \" + url, event.filename, event.lineno, event.column));\n          }, false);\n          script.addEventListener('load', function () {\n            // Make sure the script has a moment to execute before this promise\n            // resolves.\n            setTimeout(resolve, 1);\n          }, false);\n        });\n\n        script.src = url;\n        document.head.appendChild(script);\n        return promise;\n      }\n\n      function loadScript(url, opts) {\n        var pr = void 0;\n        if (isContentScript()) {\n          (function () {\n            var attempt = function attempt(retryNum, lastErr) {\n              if (retryNum > 3) {\n                throw lastErr || new Error(\"Ran out of loadScript attempts for unknown reason\");\n              }\n\n              return (0, _ajax2.default)({\n                url: url, cachebust: retryNum > 0\n              }).then(function (response) {\n                // Q: Why put the code into a function before executing it instead of\n                //    evaling it immediately?\n                // A: Chrome would execute it before applying any remembered\n                //    breakpoints.\n                // Q: Why not just use `... = new Function(...)`?\n                // A: The sourcemaps would be off by one line in Chrome because of\n                //    https://code.google.com/p/chromium/issues/detail?id=109362\n                // Q: indirectEval?\n                // A: Using the eval value rather than the eval keyword causes the\n                //    code passed to it to be run in the global scope instead of the\n                //    current scope. (Seriously, it's a javascript thing.)\n                var originalCode = response.text;\n                var indirectEval = eval;\n\n                var codeParts = [];\n                if (opts && opts.disableSourceMappingURL) {\n                  // Don't remove a data: URI sourcemap (used in dev)\n                  codeParts.push(originalCode.replace(/\\/\\/# sourceMappingURL=(?!data:)[^\\n]*\\n?$/, ''));\n                } else {\n                  codeParts.push(originalCode);\n                }\n\n                if (!opts || !opts.nowrap) {\n                  codeParts.unshift(\"(function(){\");\n                  codeParts.push(\"\\n});\");\n                }\n\n                codeParts.push(\"\\n//# sourceURL=\" + url + \"\\n\");\n\n                var codeToRun = codeParts.join('');\n                var program = void 0;\n                try {\n                  program = indirectEval(codeToRun);\n                } catch (err) {\n                  if (err && err.name === 'SyntaxError') {\n                    (0, _logError2.default)(err, {\n                      retryNum: retryNum,\n                      caughtSyntaxError: true,\n                      url: url,\n                      message: 'SyntaxError in loading ' + url + '. Did we not load it fully? Trying again...'\n                    }, {});\n                    return (0, _pdelay2.default)(5000).then(function () {\n                      return attempt(retryNum + 1, err);\n                    });\n                  }\n                  // SyntaxErrors are the only errors that can happen during eval that we\n                  // retry because sometimes AppEngine doesn't serve the full javascript.\n                  // No other error is retried because other errors aren't likely to be\n                  // transient.\n                  throw err;\n                }\n                if (!opts || !opts.nowrap) {\n                  program();\n                }\n              });\n            };\n\n            pr = attempt(0, null);\n          })();\n        } else {\n          // Try to add script as CORS first so we can get error stack data from it.\n          pr = addScriptToPage(url, true).catch(function () {\n            // Only show the warning if we successfully load the script on retry.\n            return addScriptToPage(url, false).then(function () {\n              console.warn(\"Script \" + url + \" included without CORS headers. Error logs might be censored by the browser.\");\n            });\n          });\n        }\n        pr.catch(function (err) {\n          return (0, _connectivityTest2.default)().then(function (connectivityTestResults) {\n            (0, _logError2.default)(err, {\n              url: url,\n              connectivityTestResults: connectivityTestResults,\n              status: err && err.status,\n              response: err && err.xhr ? err.xhr.responseText : null,\n              message: 'Failed to load script'\n            }, {});\n          });\n        });\n        return pr;\n      }\n      module.exports = exports['default'];\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, { \"./ajax\": 52, \"./connectivity-test\": 54, \"./log-error\": 59, \"babel-runtime/core-js/promise\": 4, \"lodash/once\": 47, \"pdelay\": 48 }], 59: [function (require, module, exports) {\n    (function (global) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _keys = require('babel-runtime/core-js/object/keys');\n\n      var _keys2 = _interopRequireDefault(_keys);\n\n      var _stringify = require('babel-runtime/core-js/json/stringify');\n\n      var _stringify2 = _interopRequireDefault(_stringify);\n\n      exports.default = logError;\n\n      var _ajax = require('./ajax');\n\n      var _ajax2 = _interopRequireDefault(_ajax);\n\n      var _rateLimit = require('./rate-limit');\n\n      var _rateLimit2 = _interopRequireDefault(_rateLimit);\n\n      var _getStackTrace = require('./get-stack-trace');\n\n      var _getStackTrace2 = _interopRequireDefault(_getStackTrace);\n\n      var _getExtensionId = require('./get-extension-id');\n\n      var _getExtensionId2 = _interopRequireDefault(_getExtensionId);\n\n      var _getSessionId = require('./get-session-id');\n\n      var _getSessionId2 = _interopRequireDefault(_getSessionId);\n\n      var _version = require('./version');\n\n      var _isObject = require('lodash/isObject');\n\n      var _isObject2 = _interopRequireDefault(_isObject);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : { default: obj };\n      }\n\n      var sessionId = (0, _getSessionId2.default)();\n\n      // code inside the platform-implementation should use logger.js instead of\n      // interacting with this directly!\n\n\n      function logError(err, details, context) {\n        if (!global.document) {\n          // In tests, just throw the error.\n          throw err;\n        }\n\n        var args = arguments;\n\n        // It's important that we can't throw an error or leave a rejected promise\n        // unheard while logging an error in order to make sure to avoid ever\n        // getting into an infinite loop of reporting uncaught errors.\n        try {\n          if (haveWeSeenThisErrorAlready(err)) {\n            return;\n          } else {\n            markErrorAsSeen(err);\n          }\n\n          if (!(err instanceof Error)) {\n            console.warn('First parameter to Logger.error was not an error object:', err);\n            err = new Error(\"Logger.error called with non-error: \" + err);\n            markErrorAsSeen(err);\n          }\n          var appId = context.appId,\n              appIds = context.appIds,\n              implVersion = context.implVersion,\n              userEmailHash = context.userEmailHash;\n\n          var _loaderVersion = context.loaderVersion || _version.BUILD_VERSION;\n          var _sentByApp = !!context.sentByApp;\n\n          var errorProperties = {};\n          for (var name in err) {\n            if (Object.prototype.hasOwnProperty.call(err, name)) {\n              try {\n                var value = err[name];\n                (0, _stringify2.default)(value);\n                errorProperties[name] = value;\n              } catch (err) {\n                // ignore\n              }\n            }\n          }\n          if ((0, _keys2.default)(errorProperties).length > 0) {\n            details = { errorProperties: errorProperties, details: details };\n          }\n\n          // Might not have been passed a useful error object with a stack, so get\n          // our own current stack just in case.\n          var nowStack = (0, _getStackTrace2.default)();\n\n          var stuffToLog = [\"Error logged:\", err];\n          if (err && err.stack) {\n            stuffToLog = stuffToLog.concat([\"\\n\\nOriginal error stack:\\n\" + err.stack]);\n          }\n          stuffToLog = stuffToLog.concat([\"\\n\\nError logged from:\\n\" + nowStack]);\n          if (details) {\n            stuffToLog = stuffToLog.concat([\"\\n\\nError details:\", details]);\n          }\n          stuffToLog = stuffToLog.concat([\"\\n\\nExtension App Ids:\", (0, _stringify2.default)(appIds, null, 2)]);\n          stuffToLog = stuffToLog.concat([\"\\nSent by App:\", _sentByApp]);\n          stuffToLog = stuffToLog.concat([\"\\nSession Id:\", sessionId]);\n          stuffToLog = stuffToLog.concat([\"\\nExtension Id:\", (0, _getExtensionId2.default)()]);\n          stuffToLog = stuffToLog.concat([\"\\nInboxSDK Loader Version:\", _loaderVersion]);\n          stuffToLog = stuffToLog.concat([\"\\nInboxSDK Implementation Version:\", implVersion]);\n\n          console.error.apply(console, stuffToLog);\n\n          var report = {\n            message: err && err.message || err,\n            stack: err && err.stack,\n            loggedFrom: nowStack,\n            details: details,\n            appIds: appIds,\n            sentByApp: _sentByApp,\n            sessionId: sessionId,\n            emailHash: userEmailHash,\n            extensionId: (0, _getExtensionId2.default)(),\n            loaderVersion: _loaderVersion,\n            implementationVersion: implVersion,\n            origin: document.location.origin,\n            timestamp: Date.now() * 1000\n          };\n\n          sendError(report);\n\n          if (document.documentElement.getAttribute('inboxsdk-emit-error-event') === 'true') {\n            document.documentElement.dispatchEvent(new CustomEvent('inboxSDKerror', {\n              bubbles: false,\n              cancelable: false,\n              detail: {\n                message: err && err.message || err,\n                stack: err && err.stack,\n                loggedFrom: nowStack,\n                details: details,\n                sentByApp: _sentByApp\n              }\n            }));\n          }\n        } catch (err2) {\n          tooManyErrors(err2, args);\n        }\n      }\n\n      var _extensionSeenErrors = function () {\n        // Safari <9 doesn't have WeakSet and we don't want to pull in the polyfill,\n        // so we make one out of a WeakMap.\n        if (!global.__inboxsdk_extensionSeenErrors && global.WeakMap) {\n          Object.defineProperty(global, '__inboxsdk_extensionSeenErrors', {\n            value: new global.WeakMap()\n          });\n        }\n        return {\n          has: function has(e) {\n            if (global.__inboxsdk_extensionSeenErrors) {\n              return global.__inboxsdk_extensionSeenErrors.has(e);\n            } else {\n              try {\n                return !!e.__inboxsdk_extensionHasSeenError;\n              } catch (err) {\n                console.error(err);\n                return false;\n              }\n            }\n          },\n          add: function add(e) {\n            if (global.__inboxsdk_extensionSeenErrors && global.__inboxsdk_extensionSeenErrors.set) {\n              // It's a WeakMap.\n              global.__inboxsdk_extensionSeenErrors.set(e, true);\n            } else if (global.__inboxsdk_extensionSeenErrors && global.__inboxsdk_extensionSeenErrors.add) {\n              // Older versions of inboxsdk.js initialized it as a WeakSet instead,\n              // so handle that too.\n              global.__inboxsdk_extensionSeenErrors.add(e);\n            } else {\n              try {\n                Object.defineProperty(e, '__inboxsdk_extensionHasSeenError', {\n                  value: true\n                });\n              } catch (err) {\n                console.error(err);\n              }\n            }\n          }\n        };\n      }();\n\n      function haveWeSeenThisErrorAlready(error) {\n        if ((0, _isObject2.default)(error)) {\n          return _extensionSeenErrors.has(error);\n        }\n        return false;\n      }\n\n      function markErrorAsSeen(error) {\n        if ((0, _isObject2.default)(error)) {\n          _extensionSeenErrors.add(error);\n        }\n      }\n\n      // Only let 10 errors be sent per minute.\n      var sendError = (0, _rateLimit2.default)(function (report) {\n        var args = arguments;\n\n        try {\n          (0, _ajax2.default)({\n            url: 'https://www.inboxsdk.com/api/v2/errors',\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json'\n            },\n            data: (0, _stringify2.default)(report)\n          }).catch(function (err2) {\n            tooManyErrors(err2, args);\n          });\n        } catch (err2) {\n          tooManyErrors(err2, args);\n        }\n      }, 60 * 1000, 10);\n\n      function tooManyErrors(err2, originalArgs) {\n        console.error(\"ERROR REPORTING ERROR\", err2);\n        console.error(\"ORIGINAL ERROR\", originalArgs);\n      }\n      module.exports = exports['default'];\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, { \"./ajax\": 52, \"./get-extension-id\": 55, \"./get-session-id\": 56, \"./get-stack-trace\": 57, \"./rate-limit\": 60, \"./version\": 61, \"babel-runtime/core-js/json/stringify\": 1, \"babel-runtime/core-js/object/keys\": 3, \"lodash/isObject\": 46 }], 60: [function (require, module, exports) {\n    \"use strict\";\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.default = rateLimit;\n\n    // Returns a wrapped version of the function which throws an exception if it's\n    // called more than count times within period amount of time.\n    function rateLimit(fn, period, count) {\n      var calls = [];\n      return function () {\n        var now = Date.now();\n        calls = calls.filter(function (time) {\n          return time > now - period;\n        });\n        if (calls.length >= count) {\n          throw new Error(\"Function rate limit exceeded\");\n        }\n        calls.push(now);\n        return fn.apply(this, arguments);\n      };\n    }\n    module.exports = exports[\"default\"];\n  }, {}], 61: [function (require, module, exports) {\n    \"use strict\";\n\n    // This is in its own file so that updates to the version value don't cause a\n    // reload of everything.\n\n    exports.BUILD_VERSION = \"0.7.24-1484787998857-c248fbb55be579d3\";\n\n    if (module.hot) {\n      module.hot.accept();\n    }\n  }, {}], 62: [function (require, module, exports) {\n    (function (global) {\n      \"use strict\";\n\n      function checkRequirements(opts) {\n        if (!opts.TEMPORARY_INTERNAL_skipWeakMapRequirement && !global.WeakMap) {\n          throw new Error(\"Browser does not support WeakMap\");\n        }\n      }\n\n      module.exports = checkRequirements;\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, {}], 63: [function (require, module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var _assign = require('babel-runtime/core-js/object/assign');\n\n    var _assign2 = _interopRequireDefault(_assign);\n\n    var _logError = require('../common/log-error');\n\n    var _logError2 = _interopRequireDefault(_logError);\n\n    var _platformImplementationLoader = require('./loading/platform-implementation-loader');\n\n    var _platformImplementationLoader2 = _interopRequireDefault(_platformImplementationLoader);\n\n    var _checkRequirements = require('./check-requirements');\n\n    var _checkRequirements2 = _interopRequireDefault(_checkRequirements);\n\n    var _version = require('../common/version');\n\n    var _loadScript = require('../common/load-script');\n\n    var _loadScript2 = _interopRequireDefault(_loadScript);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { default: obj };\n    }\n\n    var InboxSDK = {\n      LOADER_VERSION: _version.BUILD_VERSION,\n      loadScript: _loadScript2.default,\n      load: function load(version, appId, opts) {\n        opts = (0, _assign2.default)({\n          // defaults\n          globalErrorLogging: true\n        }, opts, {\n          // stuff that can't be overridden, such as extra stuff this file passes to\n          // the implementation script.\n          VERSION: InboxSDK.LOADER_VERSION,\n          REQUESTED_API_VERSION: version\n        });\n\n        (0, _checkRequirements2.default)(opts);\n\n        return _platformImplementationLoader2.default.load(appId, opts);\n      }\n    };\n\n    if (['https://mail.google.com', 'https://inbox.google.com'].indexOf(document.location.origin) != -1) {\n      _platformImplementationLoader2.default.preload();\n    }\n\n    exports.default = InboxSDK;\n    module.exports = exports['default'];\n  }, { \"../common/load-script\": 58, \"../common/log-error\": 59, \"../common/version\": 61, \"./check-requirements\": 62, \"./loading/platform-implementation-loader\": 64, \"babel-runtime/core-js/object/assign\": 2 }], 64: [function (require, module, exports) {\n    (function (global) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _promise = require('babel-runtime/core-js/promise');\n\n      var _promise2 = _interopRequireDefault(_promise);\n\n      var _loadScript = require('../../common/load-script');\n\n      var _loadScript2 = _interopRequireDefault(_loadScript);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : { default: obj };\n      }\n\n      var once = require('lodash/once');\n\n      var PlatformImplementationLoader = {\n        load: function load(appId, opts) {\n          return _promise2.default.resolve().then(function () {\n            if (!global.__InboxSDKImpLoader) {\n              return PlatformImplementationLoader._loadScript().then(function () {\n                if (!global.__InboxSDKImpLoader) {\n                  throw new Error(\"Implementation file did not load correctly\");\n                }\n              });\n            }\n          }).then(function () {\n            return global.__InboxSDKImpLoader.load(\"0.1\", appId, opts);\n          });\n        },\n\n        _loadScript: once(function () {\n          var disableSourceMappingURL = true;\n          if (window.localStorage) {\n            try {\n              disableSourceMappingURL = localStorage.getItem('inboxsdk__enable_sourcemap') !== 'true';\n            } catch (err) {\n              console.error(err);\n            }\n          }\n\n          return (0, _loadScript2.default)('https://www.inboxsdk.com/build/platform-implementation.js', {\n            nowrap: true, // platform-implementation has no top-level vars so no need for function wrapping\n            disableSourceMappingURL: disableSourceMappingURL\n          });\n        }),\n\n        preload: function preload() {\n          // Prime the load by calling it and letting the promise be memoized.\n          this._loadScript();\n        }\n      };\n\n      exports.default = PlatformImplementationLoader;\n      module.exports = exports['default'];\n    }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n  }, { \"../../common/load-script\": 58, \"babel-runtime/core-js/promise\": 4, \"lodash/once\": 47 }], 65: [function (require, module, exports) {\n    \"use strict\";\n\n    var oldDefine;\n    try {\n      if (\"function\" !== \"undefined\" && __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n        // work around amd compatibility issue\n        // https://groups.google.com/forum/#!msg/inboxsdk/U_bq82Exmwc/I3iIinxxCAAJ\n        oldDefine = __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\");\n        __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") = null;\n      }\n      // exposes main as a global for browsers\n      window.InboxSDK = require('./inboxsdk');\n    } finally {\n      if (__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")) {\n        define = __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\");\n      }\n    }\n  }, { \"./inboxsdk\": 63 }] }, {}, [65]);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL3V0aWxzL2luYm94c2RrLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvdXRpbHMvaW5ib3hzZGsuanM/NjdiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEluYm94U0RLXG4gKiBodHRwczovL3d3dy5pbmJveHNkay5jb20vXG4gKlxuICogVGhlIHVzZSBvZiBJbmJveFNESyBpcyBnb3Zlcm5lZCBieSB0aGUgVGVybXMgb2YgU2VydmljZXMgbG9jYXRlZCBhdFxuICogaHR0cHM6Ly93d3cuaW5ib3hzZGsuY29tL3Rlcm1zXG5cblxuICogIF9fICAgIF9fICAgICAgICAgICAgXyAgICAgXyAgICAgICAgICBfICAgICAgICAgICAgICAgIF8gICAgICAgICAgICAgICAgICAgICAgX19fICAgICAgICAgICAgICAgICBfIF8gX19fXG4gKiAvIC8gL1xcIFxcIFxcX18gXyBfIF9fIHwgfF8gIHwgfF8gX19fICAgfCB8X18gICBfXyBfICBfX198IHwgX18gICBfX18gIF8gX18gICAgIC8gXyBcXF8gX18gX19fICAgX18gXyhfKSAvIF8gXFxcbiAqIFxcIFxcLyAgXFwvIC8gX2AgfCAnXyBcXHwgX198IHwgX18vIF8gXFwgIHwgJ18gXFwgLyBfYCB8LyBfX3wgfC8gLyAgLyBfIFxcfCAnXyBcXCAgIC8gL19cXC8gJ18gYCBfIFxcIC8gX2AgfCB8IFxcLy8gL1xuICogIFxcICAvXFwgIC8gKF98IHwgfCB8IHwgfF8gIHwgfHwgKF8pIHwgfCB8IHwgfCAoX3wgfCAoX198ICAgPCAgfCAoXykgfCB8IHwgfCAvIC9fXFxcXHwgfCB8IHwgfCB8IChffCB8IHwgfCBcXC9cbiAqICAgXFwvICBcXC8gXFxfXyxffF98IHxffFxcX198ICBcXF9fXFxfX18vICB8X3wgfF98XFxfXyxffFxcX19ffF98XFxfXFwgIFxcX19fL3xffCB8X3wgXFxfX19fL3xffCB8X3wgfF98XFxfXyxffF98X3wgKClcbiAqXG4gKiBMaWtlIGNvbXBsZXggcmV2ZXJzZSBlbmdpbmVlcmluZz8gV2FudCB0byBtYWtlIEdtYWlsIGFuZCBJbmJveCBhIGhhY2thYmxlIHBsYXRmb3JtP1xuICpcbiAqIEpvaW4gdXMgYXQ6IHd3dy5zdHJlYWsuY29tL2NhcmVlcnM/c291cmNlPXNka1xuICovXG5cbihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSx7XCJjb3JlLWpzL2xpYnJhcnkvZm4vanNvbi9zdHJpbmdpZnlcIjo1fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSx7XCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnblwiOjZ9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qva2V5c1wiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSx7XCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2tleXNcIjo3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vLyBXZSBvbmx5IHRhcmdldCBicm93c2VycyB0aGF0IG5hdGl2ZWx5IHN1cHBvcnQgUHJvbWlzZXMsIHNvIHdlIHJlcGxhY2Vcbi8vIEJhYmVsJ3MgUHJvbWlzZSBoZWxwZXIgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgbmF0aXZlIHByb21pc2UuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgX19lc01vZHVsZTogdHJ1ZSxcbiAgZGVmYXVsdDogZ2xvYmFsLlByb21pc2Vcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBjb3JlICA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKVxuICAsICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7c3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeX0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xufSx7XCIuLi8uLi9tb2R1bGVzL19jb3JlXCI6MTJ9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247XG59LHtcIi4uLy4uL21vZHVsZXMvX2NvcmVcIjoxMixcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ25cIjo0M31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmtleXMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5rZXlzO1xufSx7XCIuLi8uLi9tb2R1bGVzL19jb3JlXCI6MTIsXCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5c1wiOjQ0fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbn0se31dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG59LHtcIi4vX2lzLW9iamVjdFwiOjI1fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xufSx7XCIuL190by1pbmRleFwiOjM2LFwiLi9fdG8taW9iamVjdFwiOjM4LFwiLi9fdG8tbGVuZ3RoXCI6Mzl9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xufSx7fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbn0se1wiLi9fYS1mdW5jdGlvblwiOjh9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG59LHt9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTtcbn0se1wiLi9fZmFpbHNcIjoxOX1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbn0se1wiLi9fZ2xvYmFsXCI6MjAsXCIuL19pcy1vYmplY3RcIjoyNX1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xufSx7fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXVxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwga2V5LCBvd24sIG91dDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uKEMpe1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgICAgaWYodGhpcyBpbnN0YW5jZW9mIEMpe1xuICAgICAgICAgIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZihJU19QUk9UTyl7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSloaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbn0se1wiLi9fY29yZVwiOjEyLFwiLi9fY3R4XCI6MTMsXCIuL19nbG9iYWxcIjoyMCxcIi4vX2hpZGVcIjoyMn1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufSx7fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG59LHt9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG59LHtcIi4vX2Rlc2NyaXB0b3JzXCI6MTUsXCIuL19vYmplY3QtZHBcIjoyNyxcIi4vX3Byb3BlcnR5LWRlc2NcIjozM31dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG59LHtcIi4vX2Rlc2NyaXB0b3JzXCI6MTUsXCIuL19kb20tY3JlYXRlXCI6MTYsXCIuL19mYWlsc1wiOjE5fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG59LHtcIi4vX2NvZlwiOjExfV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xufSx7fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbn0se1wiLi9fZmFpbHNcIjoxOSxcIi4vX2lvYmplY3RcIjoyNCxcIi4vX29iamVjdC1nb3BzXCI6MjgsXCIuL19vYmplY3Qta2V5c1wiOjMwLFwiLi9fb2JqZWN0LXBpZVwiOjMxLFwiLi9fdG8tb2JqZWN0XCI6NDB9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xufSx7XCIuL19hbi1vYmplY3RcIjo5LFwiLi9fZGVzY3JpcHRvcnNcIjoxNSxcIi4vX2llOC1kb20tZGVmaW5lXCI6MjMsXCIuL190by1wcmltaXRpdmVcIjo0MX1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG59LHt9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG59LHtcIi4vX2FycmF5LWluY2x1ZGVzXCI6MTAsXCIuL19oYXNcIjoyMSxcIi4vX3NoYXJlZC1rZXlcIjozNCxcIi4vX3RvLWlvYmplY3RcIjozOH1dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xufSx7XCIuL19lbnVtLWJ1Zy1rZXlzXCI6MTcsXCIuL19vYmplY3Qta2V5cy1pbnRlcm5hbFwiOjI5fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG59LHt9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xufSx7XCIuL19jb3JlXCI6MTIsXCIuL19leHBvcnRcIjoxOCxcIi4vX2ZhaWxzXCI6MTl9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG59LHt9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbn0se1wiLi9fc2hhcmVkXCI6MzUsXCIuL191aWRcIjo0Mn1dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG59LHtcIi4vX2dsb2JhbFwiOjIwfV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbn0se1wiLi9fdG8taW50ZWdlclwiOjM3fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbn0se1wiLi9fZGVmaW5lZFwiOjE0LFwiLi9faW9iamVjdFwiOjI0fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG59LHtcIi4vX3RvLWludGVnZXJcIjozN31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbn0se1wiLi9fZGVmaW5lZFwiOjE0fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG59LHtcIi4vX2lzLW9iamVjdFwiOjI1fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG59LHt9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTtcbn0se1wiLi9fZXhwb3J0XCI6MTgsXCIuL19vYmplY3QtYXNzaWduXCI6MjZ9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbn0se1wiLi9fb2JqZWN0LWtleXNcIjozMCxcIi4vX29iamVjdC1zYXBcIjozMixcIi4vX3RvLW9iamVjdFwiOjQwfV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbmZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnJvbVBhaXJzO1xuXG59LHt9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxufSx7fV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uY2U7XG5cbmZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIG11c3QgYmUgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgcmVzdWx0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZ1bmMpIHtcbiAgICAgIHZhciB0ZW1wRnVuYyA9IGZ1bmM7XG4gICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgcmVzdWx0ID0gdGVtcEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxufSx7fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBkZWxheTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZGVsYXkodGltZSwgdmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgdGltZSk7XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxufSx7XCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiOjR9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxufSx7fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cbn0se1wiLi9kZWNvZGVcIjo0OSxcIi4vZW5jb2RlXCI6NTB9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfa2V5cyA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5cycpO1xuXG52YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24nKTtcblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UnKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhamF4O1xuXG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxudmFyIF9xdWVyeXN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWVyeXN0cmluZyk7XG5cbnZhciBfcGRlbGF5ID0gcmVxdWlyZSgncGRlbGF5Jyk7XG5cbnZhciBfcGRlbGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BkZWxheSk7XG5cbnZhciBfY2FjaGVidXN0VXJsID0gcmVxdWlyZSgnLi9jYWNoZWJ1c3QtdXJsJyk7XG5cbnZhciBfY2FjaGVidXN0VXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhY2hlYnVzdFVybCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBNQVhfVElNRU9VVCA9IDY0ICogMTAwMDsgLy82NCBzZWNvbmRzXG5cblxudmFyIE1BWF9SRVRSSUVTID0gNTtcbnZhciBzZXJ2ZXJzVG9JZ25vcmUgPSB7fTtcblxuLy8gU2ltcGxlIGFqYXggaGVscGVyLlxuLy8gb3B0czpcbi8vICogdXJsXG4vLyAqIFttZXRob2RdXG4vLyAqIFtjYWNoZWJ1c3RdIC0gYm9vbGVhblxuLy8gKiBbaGVhZGVyc10gLSBvYmplY3Rcbi8vICogW3hockZpZWxkc10gLSBvYmplY3Rcbi8vICogW2RhdGFdXG5mdW5jdGlvbiBhamF4KG9wdHMpIHtcbiAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzLnVybCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTCBtdXN0IGJlIGdpdmVuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIG1ldGhvZCA9IG9wdHMubWV0aG9kID8gb3B0cy5tZXRob2QgOiBcIkdFVFwiO1xuICAgIHZhciB1cmwgPSBvcHRzLnVybDtcbiAgICB2YXIgc3RyaW5nRGF0YSA9IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICBzdHJpbmdEYXRhID0gdHlwZW9mIG9wdHMuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IG9wdHMuZGF0YSA6IF9xdWVyeXN0cmluZzIuZGVmYXVsdC5zdHJpbmdpZnkob3B0cy5kYXRhKTtcbiAgICAgIGlmIChtZXRob2QgPT09IFwiR0VUXCIgfHwgbWV0aG9kID09PSBcIkhFQURcIikge1xuICAgICAgICB1cmwgKz0gKC9cXD8vLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCIpICsgc3RyaW5nRGF0YTtcbiAgICAgICAgc3RyaW5nRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gdXJsLm1hdGNoKC8oPzooPzpbYS16XSs6KT9cXC9cXC8pPyhbXi9dKilcXC8vKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbWF0Y2ggdXJsXCIpO1xuICAgIH1cbiAgICB2YXIgc2VydmVyID0gbWF0Y2hbMV07XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXJ2ZXJzVG9JZ25vcmUsIHNlcnZlcikpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NlcnZlciBhdCAnICsgdXJsICsgJyBoYXMgdG9sZCB1cyB0byBzdG9wIGNvbm5lY3RpbmcnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuY2FjaGVidXN0KSB7XG4gICAgICB1cmwgPSAoMCwgX2NhY2hlYnVzdFVybDIuZGVmYXVsdCkodXJsKTtcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgKDAsIF9hc3NpZ24yLmRlZmF1bHQpKHhociwgb3B0cy54aHJGaWVsZHMpO1xuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoKG9wdHMucmV0cnlOdW0gfHwgMCkgPCBNQVhfUkVUUklFUykge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gNTAyIHx8ICh4aHIuc3RhdHVzID09PSAwIHx8IHhoci5zdGF0dXMgPj0gNTAwKSAmJiAobWV0aG9kID09PSBcIkdFVFwiIHx8IG1ldGhvZCA9PT0gXCJIRUFEXCIgfHwgb3B0cy5jYW5SZXRyeSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICByZXNvbHZlKF9yZXRyeShvcHRzKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnIgPSAoMCwgX2Fzc2lnbjIuZGVmYXVsdCkobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCAnICsgdXJsKSwge1xuICAgICAgICBldmVudDogZXZlbnQsIHhocjogeGhyLCBzdGF0dXM6IHhoci5zdGF0dXNcbiAgICAgIH0pO1xuXG4gICAgICAvLyBnaXZlIGEgd2F5IGZvciBhIHNlcnZlciB0byB0ZWxsIHVzIHRvIGdvIGF3YXkgZm9yIG5vdy4gR29vZCBmYWxsYmFja1xuICAgICAgLy8gaW4gY2FzZSBhIGJ1ZyBldmVyIGNhdXNlcyBjbGllbnRzIHRvIHNwYW0gYSBzZXJ2ZXIgd2l0aCByZXF1ZXN0cy5cbiAgICAgIGlmICh4aHIuc3RhdHVzID09IDQ5MCkge1xuICAgICAgICBzZXJ2ZXJzVG9JZ25vcmVbc2VydmVyXSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9O1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgeGhyOiB4aHIsXG4gICAgICAgICAgdGV4dDogeGhyLnJlc3BvbnNlVGV4dFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoci5vbmVycm9yKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAob3B0cy5oZWFkZXJzKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGVhZGVycyA9IG9wdHMuaGVhZGVycztcblxuICAgICAgICAoMCwgX2tleXMyLmRlZmF1bHQpKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBoZWFkZXJzW25hbWVdO1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH1cbiAgICB4aHIuc2VuZChzdHJpbmdEYXRhKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9yZXRyeShvcHRzKSB7XG4gIHZhciByZXRyeU51bSA9IChvcHRzLnJldHJ5TnVtIHx8IDApICsgMTtcblxuICAvLyAyMDAwIDQwMDAgODAwMC4uLlxuICB2YXIgcmV0cnlUaW1lb3V0ID0gTWF0aC5taW4oTWF0aC5wb3coMiwgcmV0cnlOdW0pICogMTAwMCwgTUFYX1RJTUVPVVQpO1xuXG4gIHJldHVybiAoMCwgX3BkZWxheTIuZGVmYXVsdCkocmV0cnlUaW1lb3V0KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWpheCgoMCwgX2Fzc2lnbjIuZGVmYXVsdCkoe30sIG9wdHMsIHsgcmV0cnlOdW06IHJldHJ5TnVtIH0pKTtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSx7XCIuL2NhY2hlYnVzdC11cmxcIjo1MyxcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCI6MixcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiOjMsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiOjQsXCJwZGVsYXlcIjo0OCxcInF1ZXJ5c3RyaW5nXCI6NTF9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNhY2hlYnVzdFVybDtcbnZhciByID0gLyhbPyZdKV89W14mXSovO1xudmFyIG5vbmNlID0gRGF0ZS5ub3coKSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIDMyKSk7XG5cbmZ1bmN0aW9uIGNhY2hlYnVzdFVybCh1cmwpIHtcbiAgaWYgKHIudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKHIsIFwiJDFfPVwiICsgbm9uY2UrKyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIG5vbmNlKys7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbn0se31dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UnKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjb25uZWN0aXZpdHlUZXN0O1xuXG52YXIgX2NhY2hlYnVzdFVybCA9IHJlcXVpcmUoJy4vY2FjaGVidXN0LXVybCcpO1xuXG52YXIgX2NhY2hlYnVzdFVybDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYWNoZWJ1c3RVcmwpO1xuXG52YXIgX2Zyb21QYWlycyA9IHJlcXVpcmUoJ2xvZGFzaC9mcm9tUGFpcnMnKTtcblxudmFyIF9mcm9tUGFpcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnJvbVBhaXJzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFVSTFMgPSBbJ2h0dHBzOi8vbWFpbGZvb2dhZS5hcHBzcG90LmNvbS9idWlsZC9pbWFnZXMvY29tcG9zZU92ZXJmbG93VG9nZ2xlLnBuZycsICdodHRwczovL3d3dy5zdHJlYWsuY29tL2J1aWxkL2ltYWdlcy9jb21wb3NlT3ZlcmZsb3dUb2dnbGUucG5nJywgJ2h0dHBzOi8vd3d3LmluYm94c2RrLmNvbS9pbWFnZXMvbG9nby1yZWQucG5nJ107XG5cbmZ1bmN0aW9uIGltYWdlVGVzdCh1cmwpIHtcbiAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXNvbHZlKHRydWUpO1xuICAgIH07XG4gICAgaW1nLm9ubG9hZGVuZCA9IGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gKDAsIF9jYWNoZWJ1c3RVcmwyLmRlZmF1bHQpKHVybCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0aXZpdHlUZXN0KCkge1xuICByZXR1cm4gX3Byb21pc2UyLmRlZmF1bHQuYWxsKFVSTFMubWFwKGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gaW1hZ2VUZXN0KHVybCkudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIFt1cmwsIHN1Y2Nlc3NdO1xuICAgIH0pO1xuICB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgIHJldHVybiAoMCwgX2Zyb21QYWlyczIuZGVmYXVsdCkocmVzdWx0cyk7XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0se1wiLi9jYWNoZWJ1c3QtdXJsXCI6NTMsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiOjQsXCJsb2Rhc2gvZnJvbVBhaXJzXCI6NDV9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRFeHRlbnNpb25JZDtcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbklkKCkge1xuICBpZiAoZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmV4dGVuc2lvbiAmJiBnbG9iYWwuY2hyb21lLmV4dGVuc2lvbi5nZXRVUkwpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNocm9tZS5leHRlbnNpb24uZ2V0VVJMKCcnKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0U2Vzc2lvbklkO1xuZnVuY3Rpb24gZ2V0U2Vzc2lvbklkKCkge1xuICB2YXIgYXR0clZhbHVlID0gZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5ib3hzZGstc2Vzc2lvbi1pZCcpO1xuICBpZiAodHlwZW9mIGF0dHJWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXR0clZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXNzaW9uSWQgPSBEYXRlLm5vdygpICsgJy0nICsgTWF0aC5yYW5kb20oKTtcbiAgICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWluYm94c2RrLXNlc3Npb24taWQnLCBzZXNzaW9uSWQpO1xuICAgIH1cbiAgICByZXR1cm4gc2Vzc2lvbklkO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0U3RhY2tUcmFjZTtcbmZ1bmN0aW9uIGdldFN0YWNrVHJhY2UoKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJTdGFjayBzYXZlclwiKTtcbiAgLy8gQ3V0IHRoZSBmaXJzdCB0d28gbGluZXMgb2ZmLiBUaGUgZmlyc3QgbGluZSBoYXMgdGhlIGVycm9yIG5hbWUsIGFuZCB0aGVcbiAgLy8gc2Vjb25kIGxpbmUgaXMgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXG4gIHJldHVybiAoXCJcIiArIGVyci5zdGFjaykucmVwbGFjZSgvXihbXlxcbl0qXFxuKXsyfS8sICcnKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wcm9taXNlID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UnKTtcblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb21pc2UpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBsb2FkU2NyaXB0O1xuXG52YXIgX2Nvbm5lY3Rpdml0eVRlc3QgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpdml0eS10ZXN0Jyk7XG5cbnZhciBfY29ubmVjdGl2aXR5VGVzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25uZWN0aXZpdHlUZXN0KTtcblxudmFyIF9sb2dFcnJvciA9IHJlcXVpcmUoJy4vbG9nLWVycm9yJyk7XG5cbnZhciBfbG9nRXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nRXJyb3IpO1xuXG52YXIgX2FqYXggPSByZXF1aXJlKCcuL2FqYXgnKTtcblxudmFyIF9hamF4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FqYXgpO1xuXG52YXIgX3BkZWxheSA9IHJlcXVpcmUoJ3BkZWxheScpO1xuXG52YXIgX3BkZWxheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wZGVsYXkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgb25jZSA9IHJlcXVpcmUoJ2xvZGFzaC9vbmNlJyk7XG5cblxudmFyIGlzQ29udGVudFNjcmlwdCA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBpZiAoZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmV4dGVuc2lvbikgcmV0dXJuIHRydWU7XG4gIGlmIChnbG9iYWwuc2FmYXJpICYmIGdsb2JhbC5zYWZhcmkuZXh0ZW5zaW9uKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufSk7XG5cbmZ1bmN0aW9uIGFkZFNjcmlwdFRvUGFnZSh1cmwsIGNvcnMpIHtcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBpZiAoY29ycykge1xuICAgIHNjcmlwdC5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgX3Byb21pc2UyLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmVqZWN0KGV2ZW50LmVycm9yIHx8IG5ldyBFcnJvcihldmVudC5tZXNzYWdlIHx8IFwiTG9hZCBmYWlsdXJlOiBcIiArIHVybCwgZXZlbnQuZmlsZW5hbWUsIGV2ZW50LmxpbmVubywgZXZlbnQuY29sdW1uKSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzY3JpcHQgaGFzIGEgbW9tZW50IHRvIGV4ZWN1dGUgYmVmb3JlIHRoaXMgcHJvbWlzZVxuICAgICAgLy8gcmVzb2x2ZXMuXG4gICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEpO1xuICAgIH0sIGZhbHNlKTtcbiAgfSk7XG5cbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbG9hZFNjcmlwdCh1cmwsIG9wdHMpIHtcbiAgdmFyIHByID0gdm9pZCAwO1xuICBpZiAoaXNDb250ZW50U2NyaXB0KCkpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGF0dGVtcHQgPSBmdW5jdGlvbiBhdHRlbXB0KHJldHJ5TnVtLCBsYXN0RXJyKSB7XG4gICAgICAgIGlmIChyZXRyeU51bSA+IDMpIHtcbiAgICAgICAgICB0aHJvdyBsYXN0RXJyIHx8IG5ldyBFcnJvcihcIlJhbiBvdXQgb2YgbG9hZFNjcmlwdCBhdHRlbXB0cyBmb3IgdW5rbm93biByZWFzb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKDAsIF9hamF4Mi5kZWZhdWx0KSh7XG4gICAgICAgICAgdXJsOiB1cmwsIGNhY2hlYnVzdDogcmV0cnlOdW0gPiAwXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gUTogV2h5IHB1dCB0aGUgY29kZSBpbnRvIGEgZnVuY3Rpb24gYmVmb3JlIGV4ZWN1dGluZyBpdCBpbnN0ZWFkIG9mXG4gICAgICAgICAgLy8gICAgZXZhbGluZyBpdCBpbW1lZGlhdGVseT9cbiAgICAgICAgICAvLyBBOiBDaHJvbWUgd291bGQgZXhlY3V0ZSBpdCBiZWZvcmUgYXBwbHlpbmcgYW55IHJlbWVtYmVyZWRcbiAgICAgICAgICAvLyAgICBicmVha3BvaW50cy5cbiAgICAgICAgICAvLyBROiBXaHkgbm90IGp1c3QgdXNlIGAuLi4gPSBuZXcgRnVuY3Rpb24oLi4uKWA/XG4gICAgICAgICAgLy8gQTogVGhlIHNvdXJjZW1hcHMgd291bGQgYmUgb2ZmIGJ5IG9uZSBsaW5lIGluIENocm9tZSBiZWNhdXNlIG9mXG4gICAgICAgICAgLy8gICAgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEwOTM2MlxuICAgICAgICAgIC8vIFE6IGluZGlyZWN0RXZhbD9cbiAgICAgICAgICAvLyBBOiBVc2luZyB0aGUgZXZhbCB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZXZhbCBrZXl3b3JkIGNhdXNlcyB0aGVcbiAgICAgICAgICAvLyAgICBjb2RlIHBhc3NlZCB0byBpdCB0byBiZSBydW4gaW4gdGhlIGdsb2JhbCBzY29wZSBpbnN0ZWFkIG9mIHRoZVxuICAgICAgICAgIC8vICAgIGN1cnJlbnQgc2NvcGUuIChTZXJpb3VzbHksIGl0J3MgYSBqYXZhc2NyaXB0IHRoaW5nLilcbiAgICAgICAgICB2YXIgb3JpZ2luYWxDb2RlID0gcmVzcG9uc2UudGV4dDtcbiAgICAgICAgICB2YXIgaW5kaXJlY3RFdmFsID0gZXZhbDtcblxuICAgICAgICAgIHZhciBjb2RlUGFydHMgPSBbXTtcbiAgICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmRpc2FibGVTb3VyY2VNYXBwaW5nVVJMKSB7XG4gICAgICAgICAgICAvLyBEb24ndCByZW1vdmUgYSBkYXRhOiBVUkkgc291cmNlbWFwICh1c2VkIGluIGRldilcbiAgICAgICAgICAgIGNvZGVQYXJ0cy5wdXNoKG9yaWdpbmFsQ29kZS5yZXBsYWNlKC9cXC9cXC8jIHNvdXJjZU1hcHBpbmdVUkw9KD8hZGF0YTopW15cXG5dKlxcbj8kLywgJycpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZVBhcnRzLnB1c2gob3JpZ2luYWxDb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW9wdHMgfHwgIW9wdHMubm93cmFwKSB7XG4gICAgICAgICAgICBjb2RlUGFydHMudW5zaGlmdChcIihmdW5jdGlvbigpe1wiKTtcbiAgICAgICAgICAgIGNvZGVQYXJ0cy5wdXNoKFwiXFxufSk7XCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvZGVQYXJ0cy5wdXNoKFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArIHVybCArIFwiXFxuXCIpO1xuXG4gICAgICAgICAgdmFyIGNvZGVUb1J1biA9IGNvZGVQYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHZvaWQgMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvZ3JhbSA9IGluZGlyZWN0RXZhbChjb2RlVG9SdW4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgICAoMCwgX2xvZ0Vycm9yMi5kZWZhdWx0KShlcnIsIHtcbiAgICAgICAgICAgICAgICByZXRyeU51bTogcmV0cnlOdW0sXG4gICAgICAgICAgICAgICAgY2F1Z2h0U3ludGF4RXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1N5bnRheEVycm9yIGluIGxvYWRpbmcgJyArIHVybCArICcuIERpZCB3ZSBub3QgbG9hZCBpdCBmdWxseT8gVHJ5aW5nIGFnYWluLi4uJ1xuICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgIHJldHVybiAoMCwgX3BkZWxheTIuZGVmYXVsdCkoNTAwMCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHQocmV0cnlOdW0gKyAxLCBlcnIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN5bnRheEVycm9ycyBhcmUgdGhlIG9ubHkgZXJyb3JzIHRoYXQgY2FuIGhhcHBlbiBkdXJpbmcgZXZhbCB0aGF0IHdlXG4gICAgICAgICAgICAvLyByZXRyeSBiZWNhdXNlIHNvbWV0aW1lcyBBcHBFbmdpbmUgZG9lc24ndCBzZXJ2ZSB0aGUgZnVsbCBqYXZhc2NyaXB0LlxuICAgICAgICAgICAgLy8gTm8gb3RoZXIgZXJyb3IgaXMgcmV0cmllZCBiZWNhdXNlIG90aGVyIGVycm9ycyBhcmVuJ3QgbGlrZWx5IHRvIGJlXG4gICAgICAgICAgICAvLyB0cmFuc2llbnQuXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3B0cyB8fCAhb3B0cy5ub3dyYXApIHtcbiAgICAgICAgICAgIHByb2dyYW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcHIgPSBhdHRlbXB0KDAsIG51bGwpO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVHJ5IHRvIGFkZCBzY3JpcHQgYXMgQ09SUyBmaXJzdCBzbyB3ZSBjYW4gZ2V0IGVycm9yIHN0YWNrIGRhdGEgZnJvbSBpdC5cbiAgICBwciA9IGFkZFNjcmlwdFRvUGFnZSh1cmwsIHRydWUpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIE9ubHkgc2hvdyB0aGUgd2FybmluZyBpZiB3ZSBzdWNjZXNzZnVsbHkgbG9hZCB0aGUgc2NyaXB0IG9uIHJldHJ5LlxuICAgICAgcmV0dXJuIGFkZFNjcmlwdFRvUGFnZSh1cmwsIGZhbHNlKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiU2NyaXB0IFwiICsgdXJsICsgXCIgaW5jbHVkZWQgd2l0aG91dCBDT1JTIGhlYWRlcnMuIEVycm9yIGxvZ3MgbWlnaHQgYmUgY2Vuc29yZWQgYnkgdGhlIGJyb3dzZXIuXCIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcHIuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiAoMCwgX2Nvbm5lY3Rpdml0eVRlc3QyLmRlZmF1bHQpKCkudGhlbihmdW5jdGlvbiAoY29ubmVjdGl2aXR5VGVzdFJlc3VsdHMpIHtcbiAgICAgICgwLCBfbG9nRXJyb3IyLmRlZmF1bHQpKGVyciwge1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgY29ubmVjdGl2aXR5VGVzdFJlc3VsdHM6IGNvbm5lY3Rpdml0eVRlc3RSZXN1bHRzLFxuICAgICAgICBzdGF0dXM6IGVyciAmJiBlcnIuc3RhdHVzLFxuICAgICAgICByZXNwb25zZTogZXJyICYmIGVyci54aHIgPyBlcnIueGhyLnJlc3BvbnNlVGV4dCA6IG51bGwsXG4gICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gbG9hZCBzY3JpcHQnXG4gICAgICB9LCB7fSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcHI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9hamF4XCI6NTIsXCIuL2Nvbm5lY3Rpdml0eS10ZXN0XCI6NTQsXCIuL2xvZy1lcnJvclwiOjU5LFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIjo0LFwibG9kYXNoL29uY2VcIjo0NyxcInBkZWxheVwiOjQ4fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2tleXMgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXMnKTtcblxudmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG52YXIgX3N0cmluZ2lmeSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeScpO1xuXG52YXIgX3N0cmluZ2lmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmdpZnkpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBsb2dFcnJvcjtcblxudmFyIF9hamF4ID0gcmVxdWlyZSgnLi9hamF4Jyk7XG5cbnZhciBfYWpheDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hamF4KTtcblxudmFyIF9yYXRlTGltaXQgPSByZXF1aXJlKCcuL3JhdGUtbGltaXQnKTtcblxudmFyIF9yYXRlTGltaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmF0ZUxpbWl0KTtcblxudmFyIF9nZXRTdGFja1RyYWNlID0gcmVxdWlyZSgnLi9nZXQtc3RhY2stdHJhY2UnKTtcblxudmFyIF9nZXRTdGFja1RyYWNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFN0YWNrVHJhY2UpO1xuXG52YXIgX2dldEV4dGVuc2lvbklkID0gcmVxdWlyZSgnLi9nZXQtZXh0ZW5zaW9uLWlkJyk7XG5cbnZhciBfZ2V0RXh0ZW5zaW9uSWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RXh0ZW5zaW9uSWQpO1xuXG52YXIgX2dldFNlc3Npb25JZCA9IHJlcXVpcmUoJy4vZ2V0LXNlc3Npb24taWQnKTtcblxudmFyIF9nZXRTZXNzaW9uSWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0U2Vzc2lvbklkKTtcblxudmFyIF92ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbnZhciBfaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNPYmplY3QnKTtcblxudmFyIF9pc09iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc09iamVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzZXNzaW9uSWQgPSAoMCwgX2dldFNlc3Npb25JZDIuZGVmYXVsdCkoKTtcblxuLy8gY29kZSBpbnNpZGUgdGhlIHBsYXRmb3JtLWltcGxlbWVudGF0aW9uIHNob3VsZCB1c2UgbG9nZ2VyLmpzIGluc3RlYWQgb2Zcbi8vIGludGVyYWN0aW5nIHdpdGggdGhpcyBkaXJlY3RseSFcblxuXG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIGRldGFpbHMsIGNvbnRleHQpIHtcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAvLyBJbiB0ZXN0cywganVzdCB0aHJvdyB0aGUgZXJyb3IuXG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBjYW4ndCB0aHJvdyBhbiBlcnJvciBvciBsZWF2ZSBhIHJlamVjdGVkIHByb21pc2VcbiAgLy8gdW5oZWFyZCB3aGlsZSBsb2dnaW5nIGFuIGVycm9yIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSB0byBhdm9pZCBldmVyXG4gIC8vIGdldHRpbmcgaW50byBhbiBpbmZpbml0ZSBsb29wIG9mIHJlcG9ydGluZyB1bmNhdWdodCBlcnJvcnMuXG4gIHRyeSB7XG4gICAgaWYgKGhhdmVXZVNlZW5UaGlzRXJyb3JBbHJlYWR5KGVycikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya0Vycm9yQXNTZWVuKGVycik7XG4gICAgfVxuXG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZpcnN0IHBhcmFtZXRlciB0byBMb2dnZXIuZXJyb3Igd2FzIG5vdCBhbiBlcnJvciBvYmplY3Q6JywgZXJyKTtcbiAgICAgIGVyciA9IG5ldyBFcnJvcihcIkxvZ2dlci5lcnJvciBjYWxsZWQgd2l0aCBub24tZXJyb3I6IFwiICsgZXJyKTtcbiAgICAgIG1hcmtFcnJvckFzU2VlbihlcnIpO1xuICAgIH1cbiAgICB2YXIgYXBwSWQgPSBjb250ZXh0LmFwcElkLFxuICAgICAgICBhcHBJZHMgPSBjb250ZXh0LmFwcElkcyxcbiAgICAgICAgaW1wbFZlcnNpb24gPSBjb250ZXh0LmltcGxWZXJzaW9uLFxuICAgICAgICB1c2VyRW1haWxIYXNoID0gY29udGV4dC51c2VyRW1haWxIYXNoO1xuXG4gICAgdmFyIF9sb2FkZXJWZXJzaW9uID0gY29udGV4dC5sb2FkZXJWZXJzaW9uIHx8IF92ZXJzaW9uLkJVSUxEX1ZFUlNJT047XG4gICAgdmFyIF9zZW50QnlBcHAgPSAhIWNvbnRleHQuc2VudEJ5QXBwO1xuXG4gICAgdmFyIGVycm9yUHJvcGVydGllcyA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gZXJyKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgbmFtZSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBlcnJbbmFtZV07XG4gICAgICAgICAgKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKHZhbHVlKTtcbiAgICAgICAgICBlcnJvclByb3BlcnRpZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCgwLCBfa2V5czIuZGVmYXVsdCkoZXJyb3JQcm9wZXJ0aWVzKS5sZW5ndGggPiAwKSB7XG4gICAgICBkZXRhaWxzID0geyBlcnJvclByb3BlcnRpZXM6IGVycm9yUHJvcGVydGllcywgZGV0YWlsczogZGV0YWlscyB9O1xuICAgIH1cblxuICAgIC8vIE1pZ2h0IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGEgdXNlZnVsIGVycm9yIG9iamVjdCB3aXRoIGEgc3RhY2ssIHNvIGdldFxuICAgIC8vIG91ciBvd24gY3VycmVudCBzdGFjayBqdXN0IGluIGNhc2UuXG4gICAgdmFyIG5vd1N0YWNrID0gKDAsIF9nZXRTdGFja1RyYWNlMi5kZWZhdWx0KSgpO1xuXG4gICAgdmFyIHN0dWZmVG9Mb2cgPSBbXCJFcnJvciBsb2dnZWQ6XCIsIGVycl07XG4gICAgaWYgKGVyciAmJiBlcnIuc3RhY2spIHtcbiAgICAgIHN0dWZmVG9Mb2cgPSBzdHVmZlRvTG9nLmNvbmNhdChbXCJcXG5cXG5PcmlnaW5hbCBlcnJvciBzdGFjazpcXG5cIiArIGVyci5zdGFja10pO1xuICAgIH1cbiAgICBzdHVmZlRvTG9nID0gc3R1ZmZUb0xvZy5jb25jYXQoW1wiXFxuXFxuRXJyb3IgbG9nZ2VkIGZyb206XFxuXCIgKyBub3dTdGFja10pO1xuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICBzdHVmZlRvTG9nID0gc3R1ZmZUb0xvZy5jb25jYXQoW1wiXFxuXFxuRXJyb3IgZGV0YWlsczpcIiwgZGV0YWlsc10pO1xuICAgIH1cbiAgICBzdHVmZlRvTG9nID0gc3R1ZmZUb0xvZy5jb25jYXQoW1wiXFxuXFxuRXh0ZW5zaW9uIEFwcCBJZHM6XCIsICgwLCBfc3RyaW5naWZ5Mi5kZWZhdWx0KShhcHBJZHMsIG51bGwsIDIpXSk7XG4gICAgc3R1ZmZUb0xvZyA9IHN0dWZmVG9Mb2cuY29uY2F0KFtcIlxcblNlbnQgYnkgQXBwOlwiLCBfc2VudEJ5QXBwXSk7XG4gICAgc3R1ZmZUb0xvZyA9IHN0dWZmVG9Mb2cuY29uY2F0KFtcIlxcblNlc3Npb24gSWQ6XCIsIHNlc3Npb25JZF0pO1xuICAgIHN0dWZmVG9Mb2cgPSBzdHVmZlRvTG9nLmNvbmNhdChbXCJcXG5FeHRlbnNpb24gSWQ6XCIsICgwLCBfZ2V0RXh0ZW5zaW9uSWQyLmRlZmF1bHQpKCldKTtcbiAgICBzdHVmZlRvTG9nID0gc3R1ZmZUb0xvZy5jb25jYXQoW1wiXFxuSW5ib3hTREsgTG9hZGVyIFZlcnNpb246XCIsIF9sb2FkZXJWZXJzaW9uXSk7XG4gICAgc3R1ZmZUb0xvZyA9IHN0dWZmVG9Mb2cuY29uY2F0KFtcIlxcbkluYm94U0RLIEltcGxlbWVudGF0aW9uIFZlcnNpb246XCIsIGltcGxWZXJzaW9uXSk7XG5cbiAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIHN0dWZmVG9Mb2cpO1xuXG4gICAgdmFyIHJlcG9ydCA9IHtcbiAgICAgIG1lc3NhZ2U6IGVyciAmJiBlcnIubWVzc2FnZSB8fCBlcnIsXG4gICAgICBzdGFjazogZXJyICYmIGVyci5zdGFjayxcbiAgICAgIGxvZ2dlZEZyb206IG5vd1N0YWNrLFxuICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgIGFwcElkczogYXBwSWRzLFxuICAgICAgc2VudEJ5QXBwOiBfc2VudEJ5QXBwLFxuICAgICAgc2Vzc2lvbklkOiBzZXNzaW9uSWQsXG4gICAgICBlbWFpbEhhc2g6IHVzZXJFbWFpbEhhc2gsXG4gICAgICBleHRlbnNpb25JZDogKDAsIF9nZXRFeHRlbnNpb25JZDIuZGVmYXVsdCkoKSxcbiAgICAgIGxvYWRlclZlcnNpb246IF9sb2FkZXJWZXJzaW9uLFxuICAgICAgaW1wbGVtZW50YXRpb25WZXJzaW9uOiBpbXBsVmVyc2lvbixcbiAgICAgIG9yaWdpbjogZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpICogMTAwMFxuICAgIH07XG5cbiAgICBzZW5kRXJyb3IocmVwb3J0KTtcblxuICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpbmJveHNkay1lbWl0LWVycm9yLWV2ZW50JykgPT09ICd0cnVlJykge1xuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpbmJveFNES2Vycm9yJywge1xuICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIG1lc3NhZ2U6IGVyciAmJiBlcnIubWVzc2FnZSB8fCBlcnIsXG4gICAgICAgICAgc3RhY2s6IGVyciAmJiBlcnIuc3RhY2ssXG4gICAgICAgICAgbG9nZ2VkRnJvbTogbm93U3RhY2ssXG4gICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICBzZW50QnlBcHA6IF9zZW50QnlBcHBcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyMikge1xuICAgIHRvb01hbnlFcnJvcnMoZXJyMiwgYXJncyk7XG4gIH1cbn1cblxudmFyIF9leHRlbnNpb25TZWVuRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAvLyBTYWZhcmkgPDkgZG9lc24ndCBoYXZlIFdlYWtTZXQgYW5kIHdlIGRvbid0IHdhbnQgdG8gcHVsbCBpbiB0aGUgcG9seWZpbGwsXG4gIC8vIHNvIHdlIG1ha2Ugb25lIG91dCBvZiBhIFdlYWtNYXAuXG4gIGlmICghZ2xvYmFsLl9faW5ib3hzZGtfZXh0ZW5zaW9uU2VlbkVycm9ycyAmJiBnbG9iYWwuV2Vha01hcCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsICdfX2luYm94c2RrX2V4dGVuc2lvblNlZW5FcnJvcnMnLCB7XG4gICAgICB2YWx1ZTogbmV3IGdsb2JhbC5XZWFrTWFwKClcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzKGUpIHtcbiAgICAgIGlmIChnbG9iYWwuX19pbmJveHNka19leHRlbnNpb25TZWVuRXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuX19pbmJveHNka19leHRlbnNpb25TZWVuRXJyb3JzLmhhcyhlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuICEhZS5fX2luYm94c2RrX2V4dGVuc2lvbkhhc1NlZW5FcnJvcjtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoZSkge1xuICAgICAgaWYgKGdsb2JhbC5fX2luYm94c2RrX2V4dGVuc2lvblNlZW5FcnJvcnMgJiYgZ2xvYmFsLl9faW5ib3hzZGtfZXh0ZW5zaW9uU2VlbkVycm9ycy5zZXQpIHtcbiAgICAgICAgLy8gSXQncyBhIFdlYWtNYXAuXG4gICAgICAgIGdsb2JhbC5fX2luYm94c2RrX2V4dGVuc2lvblNlZW5FcnJvcnMuc2V0KGUsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChnbG9iYWwuX19pbmJveHNka19leHRlbnNpb25TZWVuRXJyb3JzICYmIGdsb2JhbC5fX2luYm94c2RrX2V4dGVuc2lvblNlZW5FcnJvcnMuYWRkKSB7XG4gICAgICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIGluYm94c2RrLmpzIGluaXRpYWxpemVkIGl0IGFzIGEgV2Vha1NldCBpbnN0ZWFkLFxuICAgICAgICAvLyBzbyBoYW5kbGUgdGhhdCB0b28uXG4gICAgICAgIGdsb2JhbC5fX2luYm94c2RrX2V4dGVuc2lvblNlZW5FcnJvcnMuYWRkKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19faW5ib3hzZGtfZXh0ZW5zaW9uSGFzU2VlbkVycm9yJywge1xuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBoYXZlV2VTZWVuVGhpc0Vycm9yQWxyZWFkeShlcnJvcikge1xuICBpZiAoKDAsIF9pc09iamVjdDIuZGVmYXVsdCkoZXJyb3IpKSB7XG4gICAgcmV0dXJuIF9leHRlbnNpb25TZWVuRXJyb3JzLmhhcyhlcnJvcik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtYXJrRXJyb3JBc1NlZW4oZXJyb3IpIHtcbiAgaWYgKCgwLCBfaXNPYmplY3QyLmRlZmF1bHQpKGVycm9yKSkge1xuICAgIF9leHRlbnNpb25TZWVuRXJyb3JzLmFkZChlcnJvcik7XG4gIH1cbn1cblxuLy8gT25seSBsZXQgMTAgZXJyb3JzIGJlIHNlbnQgcGVyIG1pbnV0ZS5cbnZhciBzZW5kRXJyb3IgPSAoMCwgX3JhdGVMaW1pdDIuZGVmYXVsdCkoZnVuY3Rpb24gKHJlcG9ydCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICB0cnkge1xuICAgICgwLCBfYWpheDIuZGVmYXVsdCkoe1xuICAgICAgdXJsOiAnaHR0cHM6Ly93d3cuaW5ib3hzZGsuY29tL2FwaS92Mi9lcnJvcnMnLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBkYXRhOiAoMCwgX3N0cmluZ2lmeTIuZGVmYXVsdCkocmVwb3J0KVxuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgICB0b29NYW55RXJyb3JzKGVycjIsIGFyZ3MpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIyKSB7XG4gICAgdG9vTWFueUVycm9ycyhlcnIyLCBhcmdzKTtcbiAgfVxufSwgNjAgKiAxMDAwLCAxMCk7XG5cbmZ1bmN0aW9uIHRvb01hbnlFcnJvcnMoZXJyMiwgb3JpZ2luYWxBcmdzKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJFUlJPUiBSRVBPUlRJTkcgRVJST1JcIiwgZXJyMik7XG4gIGNvbnNvbGUuZXJyb3IoXCJPUklHSU5BTCBFUlJPUlwiLCBvcmlnaW5hbEFyZ3MpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vYWpheFwiOjUyLFwiLi9nZXQtZXh0ZW5zaW9uLWlkXCI6NTUsXCIuL2dldC1zZXNzaW9uLWlkXCI6NTYsXCIuL2dldC1zdGFjay10cmFjZVwiOjU3LFwiLi9yYXRlLWxpbWl0XCI6NjAsXCIuL3ZlcnNpb25cIjo2MSxcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeVwiOjEsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIjozLFwibG9kYXNoL2lzT2JqZWN0XCI6NDZ9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJhdGVMaW1pdDtcblxuXG4vLyBSZXR1cm5zIGEgd3JhcHBlZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbiB3aGljaCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIGl0J3Ncbi8vIGNhbGxlZCBtb3JlIHRoYW4gY291bnQgdGltZXMgd2l0aGluIHBlcmlvZCBhbW91bnQgb2YgdGltZS5cbmZ1bmN0aW9uIHJhdGVMaW1pdChmbiwgcGVyaW9kLCBjb3VudCkge1xuICB2YXIgY2FsbHMgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjYWxscyA9IGNhbGxzLmZpbHRlcihmdW5jdGlvbiAodGltZSkge1xuICAgICAgcmV0dXJuIHRpbWUgPiBub3cgLSBwZXJpb2Q7XG4gICAgfSk7XG4gICAgaWYgKGNhbGxzLmxlbmd0aCA+PSBjb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gcmF0ZSBsaW1pdCBleGNlZWRlZFwiKTtcbiAgICB9XG4gICAgY2FsbHMucHVzaChub3cpO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgaXMgaW4gaXRzIG93biBmaWxlIHNvIHRoYXQgdXBkYXRlcyB0byB0aGUgdmVyc2lvbiB2YWx1ZSBkb24ndCBjYXVzZSBhXG4vLyByZWxvYWQgb2YgZXZlcnl0aGluZy5cblxuZXhwb3J0cy5CVUlMRF9WRVJTSU9OID0gXCIwLjcuMjQtMTQ4NDc4Nzk5ODg1Ny1jMjQ4ZmJiNTViZTU3OWQzXCI7XG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KCk7XG59XG5cbn0se31dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBjaGVja1JlcXVpcmVtZW50cyhvcHRzKSB7XG4gIGlmICghb3B0cy5URU1QT1JBUllfSU5URVJOQUxfc2tpcFdlYWtNYXBSZXF1aXJlbWVudCAmJiAhZ2xvYmFsLldlYWtNYXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2Vha01hcFwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVxdWlyZW1lbnRzO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduJyk7XG5cbnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cbnZhciBfbG9nRXJyb3IgPSByZXF1aXJlKCcuLi9jb21tb24vbG9nLWVycm9yJyk7XG5cbnZhciBfbG9nRXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nRXJyb3IpO1xuXG52YXIgX3BsYXRmb3JtSW1wbGVtZW50YXRpb25Mb2FkZXIgPSByZXF1aXJlKCcuL2xvYWRpbmcvcGxhdGZvcm0taW1wbGVtZW50YXRpb24tbG9hZGVyJyk7XG5cbnZhciBfcGxhdGZvcm1JbXBsZW1lbnRhdGlvbkxvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybUltcGxlbWVudGF0aW9uTG9hZGVyKTtcblxudmFyIF9jaGVja1JlcXVpcmVtZW50cyA9IHJlcXVpcmUoJy4vY2hlY2stcmVxdWlyZW1lbnRzJyk7XG5cbnZhciBfY2hlY2tSZXF1aXJlbWVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2hlY2tSZXF1aXJlbWVudHMpO1xuXG52YXIgX3ZlcnNpb24gPSByZXF1aXJlKCcuLi9jb21tb24vdmVyc2lvbicpO1xuXG52YXIgX2xvYWRTY3JpcHQgPSByZXF1aXJlKCcuLi9jb21tb24vbG9hZC1zY3JpcHQnKTtcblxudmFyIF9sb2FkU2NyaXB0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvYWRTY3JpcHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgSW5ib3hTREsgPSB7XG4gIExPQURFUl9WRVJTSU9OOiBfdmVyc2lvbi5CVUlMRF9WRVJTSU9OLFxuICBsb2FkU2NyaXB0OiBfbG9hZFNjcmlwdDIuZGVmYXVsdCxcbiAgbG9hZDogZnVuY3Rpb24gbG9hZCh2ZXJzaW9uLCBhcHBJZCwgb3B0cykge1xuICAgIG9wdHMgPSAoMCwgX2Fzc2lnbjIuZGVmYXVsdCkoe1xuICAgICAgLy8gZGVmYXVsdHNcbiAgICAgIGdsb2JhbEVycm9yTG9nZ2luZzogdHJ1ZVxuICAgIH0sIG9wdHMsIHtcbiAgICAgIC8vIHN0dWZmIHRoYXQgY2FuJ3QgYmUgb3ZlcnJpZGRlbiwgc3VjaCBhcyBleHRyYSBzdHVmZiB0aGlzIGZpbGUgcGFzc2VzIHRvXG4gICAgICAvLyB0aGUgaW1wbGVtZW50YXRpb24gc2NyaXB0LlxuICAgICAgVkVSU0lPTjogSW5ib3hTREsuTE9BREVSX1ZFUlNJT04sXG4gICAgICBSRVFVRVNURURfQVBJX1ZFUlNJT046IHZlcnNpb25cbiAgICB9KTtcblxuICAgICgwLCBfY2hlY2tSZXF1aXJlbWVudHMyLmRlZmF1bHQpKG9wdHMpO1xuXG4gICAgcmV0dXJuIF9wbGF0Zm9ybUltcGxlbWVudGF0aW9uTG9hZGVyMi5kZWZhdWx0LmxvYWQoYXBwSWQsIG9wdHMpO1xuICB9XG59O1xuXG5pZiAoWydodHRwczovL21haWwuZ29vZ2xlLmNvbScsICdodHRwczovL2luYm94Lmdvb2dsZS5jb20nXS5pbmRleE9mKGRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbikgIT0gLTEpIHtcbiAgX3BsYXRmb3JtSW1wbGVtZW50YXRpb25Mb2FkZXIyLmRlZmF1bHQucHJlbG9hZCgpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmJveFNESztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG59LHtcIi4uL2NvbW1vbi9sb2FkLXNjcmlwdFwiOjU4LFwiLi4vY29tbW9uL2xvZy1lcnJvclwiOjU5LFwiLi4vY29tbW9uL3ZlcnNpb25cIjo2MSxcIi4vY2hlY2stcmVxdWlyZW1lbnRzXCI6NjIsXCIuL2xvYWRpbmcvcGxhdGZvcm0taW1wbGVtZW50YXRpb24tbG9hZGVyXCI6NjQsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiOjJ9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcHJvbWlzZSA9IHJlcXVpcmUoJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlJyk7XG5cbnZhciBfcHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9taXNlKTtcblxudmFyIF9sb2FkU2NyaXB0ID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uL2xvYWQtc2NyaXB0Jyk7XG5cbnZhciBfbG9hZFNjcmlwdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2FkU2NyaXB0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG9uY2UgPSByZXF1aXJlKCdsb2Rhc2gvb25jZScpO1xuXG5cbnZhciBQbGF0Zm9ybUltcGxlbWVudGF0aW9uTG9hZGVyID0ge1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGFwcElkLCBvcHRzKSB7XG4gICAgcmV0dXJuIF9wcm9taXNlMi5kZWZhdWx0LnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZ2xvYmFsLl9fSW5ib3hTREtJbXBMb2FkZXIpIHtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtSW1wbGVtZW50YXRpb25Mb2FkZXIuX2xvYWRTY3JpcHQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWdsb2JhbC5fX0luYm94U0RLSW1wTG9hZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbXBsZW1lbnRhdGlvbiBmaWxlIGRpZCBub3QgbG9hZCBjb3JyZWN0bHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnbG9iYWwuX19JbmJveFNES0ltcExvYWRlci5sb2FkKFwiMC4xXCIsIGFwcElkLCBvcHRzKTtcbiAgICB9KTtcbiAgfSxcblxuXG4gIF9sb2FkU2NyaXB0OiBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGlzYWJsZVNvdXJjZU1hcHBpbmdVUkwgPSB0cnVlO1xuICAgIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkaXNhYmxlU291cmNlTWFwcGluZ1VSTCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdpbmJveHNka19fZW5hYmxlX3NvdXJjZW1hcCcpICE9PSAndHJ1ZSc7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2xvYWRTY3JpcHQyLmRlZmF1bHQpKCdodHRwczovL3d3dy5pbmJveHNkay5jb20vYnVpbGQvcGxhdGZvcm0taW1wbGVtZW50YXRpb24uanMnLCB7XG4gICAgICBub3dyYXA6IHRydWUsIC8vIHBsYXRmb3JtLWltcGxlbWVudGF0aW9uIGhhcyBubyB0b3AtbGV2ZWwgdmFycyBzbyBubyBuZWVkIGZvciBmdW5jdGlvbiB3cmFwcGluZ1xuICAgICAgZGlzYWJsZVNvdXJjZU1hcHBpbmdVUkw6IGRpc2FibGVTb3VyY2VNYXBwaW5nVVJMXG4gICAgfSk7XG4gIH0pLFxuXG4gIHByZWxvYWQ6IGZ1bmN0aW9uIHByZWxvYWQoKSB7XG4gICAgLy8gUHJpbWUgdGhlIGxvYWQgYnkgY2FsbGluZyBpdCBhbmQgbGV0dGluZyB0aGUgcHJvbWlzZSBiZSBtZW1vaXplZC5cbiAgICB0aGlzLl9sb2FkU2NyaXB0KCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFBsYXRmb3JtSW1wbGVtZW50YXRpb25Mb2FkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vY29tbW9uL2xvYWQtc2NyaXB0XCI6NTgsXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiOjQsXCJsb2Rhc2gvb25jZVwiOjQ3fV0sNjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvbGREZWZpbmU7XG50cnkge1xuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIHdvcmsgYXJvdW5kIGFtZCBjb21wYXRpYmlsaXR5IGlzc3VlXG4gICAgLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9pbmJveHNkay9VX2JxODJFeG13Yy9JM2lJaW54eENBQUpcbiAgICBvbGREZWZpbmUgPSBkZWZpbmU7XG4gICAgZGVmaW5lID0gbnVsbDtcbiAgfVxuICAvLyBleHBvc2VzIG1haW4gYXMgYSBnbG9iYWwgZm9yIGJyb3dzZXJzXG4gIHdpbmRvdy5JbmJveFNESyA9IHJlcXVpcmUoJy4vaW5ib3hzZGsnKTtcbn0gZmluYWxseSB7XG4gIGlmIChvbGREZWZpbmUpIHtcbiAgICBkZWZpbmUgPSBvbGREZWZpbmU7XG4gIH1cbn1cblxufSx7XCIuL2luYm94c2RrXCI6NjN9XX0se30sWzY1XSlcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hcHAvdXRpbHMvaW5ib3hzZGsuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRkE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQUNBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFIQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBQ0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBQ0E7QUFxQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app/utils/inboxsdk.js\n");

/***/ })

})